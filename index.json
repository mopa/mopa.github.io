[{"categories":null,"content":"Con el volumen de documentos digitales que manejamos estos días, puede que hayamos llegado a una situación en la que necesitemos comprimir archivos PDF. Afortunadamente, en el mundo de Linux, contamos con varias herramientas eficientes para esto. En este post, vamos a explorar algunas de las más destacadas, siguiendo por supuesto aquellas que sean para la terminal, ya que es mi forma habitual de trabajar. Voy a ir mostrando desde las que me dan un peor resultado al mejor. Partimos de un PDF base que tiene un tamaño de 6.2 MB. ","date":"2023-02-15","objectID":"/2023/02/linux-compresi%C3%B3n-de-pdfs/:0:0","tags":["linux","tools"],"title":"[Linux] Compresión de PDFs","uri":"/2023/02/linux-compresi%C3%B3n-de-pdfs/"},{"categories":null,"content":"pdftk Es una de las opciones más conocidas y aparte de la compresión ofrece una gran cantidad de funciones para manipular PDFs. Seguramente se encuentre en los repositorios de tu distribución y una vez instalada realizamos la compresión con pdftk input.pdf output output.pdf compress ","date":"2023-02-15","objectID":"/2023/02/linux-compresi%C3%B3n-de-pdfs/:1:0","tags":["linux","tools"],"title":"[Linux] Compresión de PDFs","uri":"/2023/02/linux-compresi%C3%B3n-de-pdfs/"},{"categories":null,"content":"pdfjam Al igual que la anterior también nos ofrece más opciones para la manipulación de PDFs, pero nos interesa la compresión, la cual podemos ir variando con el parámetro scale pdfjam --scale 0.5 input.pdf ","date":"2023-02-15","objectID":"/2023/02/linux-compresi%C3%B3n-de-pdfs/:2:0","tags":["linux","tools"],"title":"[Linux] Compresión de PDFs","uri":"/2023/02/linux-compresi%C3%B3n-de-pdfs/"},{"categories":null,"content":"ghostscript Sin duda uno de los programas más conocidos y utilizados para manipular estos archivos. El «problema» que nos encontramos con él es debido a la gran cantidad de opciones de las que dispone. Para comprimir manteniendo el equilibrio entre tamaño y calidad, gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/ebook -dNOPAUSE -dQUIET -dBATCH -sOutputFile=output.pdf input.pdf ","date":"2023-02-15","objectID":"/2023/02/linux-compresi%C3%B3n-de-pdfs/:3:0","tags":["linux","tools"],"title":"[Linux] Compresión de PDFs","uri":"/2023/02/linux-compresi%C3%B3n-de-pdfs/"},{"categories":null,"content":"shrinkpdf Aunque Ghostscript nos ofrece mucho juego para poder realizar este trabajo, llega un momento en el que necesitamos que las cosas sean un poquito más simples y directas. Aquí es donde encontré una alternativa con Shrinkpdf. Existen algunos repositorios (como los AUR de Arch y derivadas) donde tenemos disponible la herramienta lista para instalar, también podemos descargarlo desde el repositorio de Github. Su uso es bastante sencillo shrinkpdf -o output.pdf input.pdf Además podemos controlar la resolución de salida en DPI shrinkpdf -r 90 -o output.pdf input.pdf O incluso hacer un conversión a escala de grises shrinkpdf -g -r 90 -o output.pdf input.pdf Con estas herramientas, deberías poder manejar cualquier necesidad de compresión de PDFs que puedas tener. Recuerda siempre hacer una copia de tus archivos originales antes de comprimirlos. ","date":"2023-02-15","objectID":"/2023/02/linux-compresi%C3%B3n-de-pdfs/:4:0","tags":["linux","tools"],"title":"[Linux] Compresión de PDFs","uri":"/2023/02/linux-compresi%C3%B3n-de-pdfs/"},{"categories":null,"content":"Aquellos que comienzan en el mundo de Python pueden verse confundidos por como pueden tener un entorno de desarrollo local sin ensuciar demasiado su sistema. Cierto es que se pueden usar los entornos virtuales, pero cuando los proyectos se van volviendo más complejos usar Docker se vuelve algo prácticamente obligatorio. Tal es así que cuando necesitamos tener control sobre las dependencias/librerías que estamos usando, vamos a tener que usar alguna herramienta adicional, bien sea con el típico requirements.txt, poetry, etc. La estructura básica de la que vamos a partir es la siguiente: app-folder ├── docker-compose.yaml ├── Dockerfile ├── requirements.txt └── src └── main.py De aquí en adelante todos los comandos se ejecutaran estando ubicados en nuestra app-folder. ","date":"2023-01-28","objectID":"/2023/01/python-desarrollo-usando-contenedores-de-docker/:0:0","tags":["python","development"],"title":"[Python] Desarrollo usando contenedores de Docker","uri":"/2023/01/python-desarrollo-usando-contenedores-de-docker/"},{"categories":null,"content":"Imagen de Docker Lo primero que necesitaremos es una imagen de Python sobre la que vamos a trabajar, es decir, a partir de esta instalaremos las dependencias que queramos. Creamos el siguiente Dockerfile FROM python:3.11-slim # Some pip settings to reduce image size and log-spam ENV PIP_DEFAULT_TIMEOUT=100 \\ PYTHONUNBUFFERED=1 \\ PIP_DISABLE_PIP_VERSION_CHECK=1 \\ PIP_NO_CACHE_DIR=1 # Set the work directory and copy our requirements WORKDIR /app COPY requirements.txt ./ RUN pip install -r requirements.txt # Some system jobs and create a user RUN set -ex \\ \u0026\u0026 addgroup --system --gid 1000 user \\ \u0026\u0026 adduser --system --uid 1000 --gid 1000 --no-create-home user \\ \u0026\u0026 apt-get update \\ \u0026\u0026 apt-get upgrade -y \\ \u0026\u0026 apt-get autoremove -y \\ \u0026\u0026 apt-get clean -y \\ \u0026\u0026 rm -rf /var/lib/apt/lists/* USER user En el fichero requirements.txt como ya sabes van todas las librerías que vamos a necesitar (aquí va un ejemplo). requests==2.28.2 beautifulsoup4\u003e=4.9.3 numpy Ahora construimos la imagen con un # docker build -t \u003cnombre imagen\u003e:\u003ctag\u003e \u003cdockerfile\u003e docker build -t pythondev:latest . ","date":"2023-01-28","objectID":"/2023/01/python-desarrollo-usando-contenedores-de-docker/:1:0","tags":["python","development"],"title":"[Python] Desarrollo usando contenedores de Docker","uri":"/2023/01/python-desarrollo-usando-contenedores-de-docker/"},{"categories":null,"content":"Arrancando la imagen Si todo a ido bien podemos crear el contenedor con el siguiente comando docker run --rm -it \\ -v $(pwd)/src:/app \\ --name pythondevcontenedor \\ pythondev:latest \\ /bin/bash Esto lo que hará será crear una nueva instancia de la imagen que hemos construido y mostrar la consola de IPython, en la cual podríamos correr el archivo que queremos. Otra opción (la que suelo usar) es arrancar una instancia pero la dejo en detach, y cuando quiero correr el script o la app entro dentro del contenedor (según el IDE que uses esto lo hace automáticamente). Para hacer esto en vez de usar el comando anterior para crear el contenedor uso este: docker run -d --rm -it \\ -v $(pwd)/src:/app \\ --name pythondevcontenedor \\ pythondev:latest \\ tail -f /dev/null OjO! Hay que tener en cuenta el flag --rm, esto implica que cuando paremos el contenedor se borrará automáticamente. Si no queremos esto, creamos dicho contenedor sin este flag. ","date":"2023-01-28","objectID":"/2023/01/python-desarrollo-usando-contenedores-de-docker/:2:0","tags":["python","development"],"title":"[Python] Desarrollo usando contenedores de Docker","uri":"/2023/01/python-desarrollo-usando-contenedores-de-docker/"},{"categories":null,"content":"Desarrollo Ahora podemos ir desarrollando nuestro código en la carpeta src y se ejecutará dentro del contenedor que hemos creado anteriormente. Depende del IDE que estemos usando, nos podremos conectar remotamente al contenedor y aprovechar todas las posibilidades que nos de el IDE. En el caso los de la familia de editores de Jetbrains tendremos que configurar el interprete, con VSCode deberemos de instalar la extensión dev containers y con el maravilloso Neovim tenemos que instalar la extensión nvim-remote-containers. ","date":"2023-01-28","objectID":"/2023/01/python-desarrollo-usando-contenedores-de-docker/:3:0","tags":["python","development"],"title":"[Python] Desarrollo usando contenedores de Docker","uri":"/2023/01/python-desarrollo-usando-contenedores-de-docker/"},{"categories":null,"content":"Como bien indica el título de este post es para dejar por aquí una chuleta para PySpark. ","date":"2022-06-07","objectID":"/2022/06/pyspark-cheatsheet-o-chuleta/:0:0","tags":["pyspark","python"],"title":"[PySpark] CheatSheet o Chuleta","uri":"/2022/06/pyspark-cheatsheet-o-chuleta/"},{"categories":null,"content":"Principales comandos Acción Comando Importar SparkSession from pyspark.sql import SparkSession Crear SparkSession spark = SparkSession.builder.appName(\"MiAplicacion\").getOrCreate() Crear RDD a partir de una lista rdd = spark.sparkContext.parallelize([1, 2, 3, 4, 5]) Crear DataFrame a partir de un archivo CSV df = spark.read.csv(\"archivo.csv\", header=True, inferSchema=True) Ver los primeros n elementos de un RDD o DataFrame rdd.take(5) / df.show(5) Ver el esquema de un DataFrame df.printSchema() Seleccionar columnas de un DataFrame df.select(\"col1\", \"col2\") Filtrar un DataFrame df.filter(df.col1 \u003e 10) Agrupar y contar elementos en un DataFrame df.groupBy(\"col1\").count() Crear una nueva columna en un DataFrame df.withColumn(\"nueva_col\", df.col1 + df.col2) Eliminar una columna de un DataFrame df.drop(\"col1\") Renombrar una columna de un DataFrame df.withColumnRenamed(\"col1\", \"nuevo_nombre\") Unir dos DataFrames df1.join(df2, on=\"clave\") Crear una tabla temporal a partir de un DataFrame df.createOrReplaceTempView(\"tabla_temp\") Ejecutar una consulta SQL en una tabla temporal spark.sql(\"SELECT * FROM tabla_temp\") Escribir un DataFrame en un archivo CSV df.write.csv(\"archivo_salida.csv\", header=True) Detener la sesión de Spark spark.stop() ","date":"2022-06-07","objectID":"/2022/06/pyspark-cheatsheet-o-chuleta/:1:0","tags":["pyspark","python"],"title":"[PySpark] CheatSheet o Chuleta","uri":"/2022/06/pyspark-cheatsheet-o-chuleta/"},{"categories":null,"content":"Transformaciones a un RDD Transformación Descripción Ejemplo map Aplica una función a cada elemento del RDD rdd.map(lambda x: x * 2) filter Filtra los elementos que cumplan una condición rdd.filter(lambda x: x \u003e 5) flatMap Aplica una función a cada elemento del RDD y devuelve una lista de resultados rdd.flatMap(lambda x: [x, x**2]) distinct Elimina los elementos duplicados del RDD rdd.distinct() sample Devuelve una muestra aleatoria del RDD rdd.sample(withReplacement=True, fraction=0.5) union Une dos RDDs rdd1.union(rdd2) intersection Devuelve los elementos que se encuentran en ambos RDDs rdd1.intersection(rdd2) subtract Elimina los elementos del primer RDD que se encuentran en el segundo RDD rdd1.subtract(rdd2) cartesian Crea todas las posibles parejas de elementos entre dos RDDs rdd1.cartesian(rdd2) sortBy Ordena los elementos del RDD según una clave rdd.sortBy(lambda x: x, ascending=False) ","date":"2022-06-07","objectID":"/2022/06/pyspark-cheatsheet-o-chuleta/:2:0","tags":["pyspark","python"],"title":"[PySpark] CheatSheet o Chuleta","uri":"/2022/06/pyspark-cheatsheet-o-chuleta/"},{"categories":null,"content":"Acciones de un RDD Acción Descripción Ejemplo collect Devuelve todos los elementos del RDD rdd.collect() count Devuelve el número de elementos del RDD rdd.count() first Devuelve el primer elemento del RDD rdd.first() take Devuelve los primeros n elementos del RDD rdd.take(5) top Devuelve los n elementos más grandes del RDD rdd.top(5) reduce Combina los elementos del RDD aplicando una función rdd.reduce(lambda x, y: x + y) foreach Aplica una función a cada elemento del RDD rdd.foreach(lambda x: print(x)) saveAsTextFile Guarda el RDD en un archivo de texto rdd.saveAsTextFile(\"ruta/al/archivo\") countByKey Cuenta el número de elementos para cada clave del RDD rdd.countByKey() takeOrdered Devuelve los n elementos más pequeños del RDD rdd.takeOrdered(5) ","date":"2022-06-07","objectID":"/2022/06/pyspark-cheatsheet-o-chuleta/:3:0","tags":["pyspark","python"],"title":"[PySpark] CheatSheet o Chuleta","uri":"/2022/06/pyspark-cheatsheet-o-chuleta/"},{"categories":null,"content":"Tarde o temprano vamos a tener la necesidad de buscar algo en la terminal, ya sean archivos, directorios, ejecutables, etc. Pues bien tenemos poderosas herramientas que por si solas o combinadas nos van a solucionar este menester ","date":"2022-01-18","objectID":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/:0:0","tags":["linux","bash","commands"],"title":"[Linux] Búsquedas por la terminal","uri":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/"},{"categories":null,"content":"whereis Con este buscamos la localización de algún binario, fuente o manual de un comando (el famoso man). whereis bash Para buscar los ficheros fuente whereis -s bash Para buscar los ficheros man whereis -m bash ","date":"2022-01-18","objectID":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/:1:0","tags":["linux","bash","commands"],"title":"[Linux] Búsquedas por la terminal","uri":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/"},{"categories":null,"content":"which Si sólo queremos la localización de un ejecutable la mejor opción es usar which. Esto es porque este comando busca el ejecutable como argumento en los directorios listados en las variables de entorno del PATH (le dice a la shell y a otros programas en que directorios buscar los ficheros ejecutables). which bash ","date":"2022-01-18","objectID":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/:2:0","tags":["linux","bash","commands"],"title":"[Linux] Búsquedas por la terminal","uri":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/"},{"categories":null,"content":"type Este comando lo anido aquí porque está muy relacionado con el anterior. Lo bueno de este, es que aparte de dar información acerca del comando buscado, nos muestra como es interpretado. Esto es que si tenemos un alias definido nos lo va a indicar. type bash ","date":"2022-01-18","objectID":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/:2:1","tags":["linux","bash","commands"],"title":"[Linux] Búsquedas por la terminal","uri":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/"},{"categories":null,"content":"locate Con locate partimos de que tenga ya una indexación de los ficheros, esto es que antes de poder usarlo hemos de ejecutar updatedb Una vez haya terminado ya si podemos buscar cualquier fichero o directorio por el nombre (aunque también podemos hacer búsquedas por patrones) locate myfile.md ","date":"2022-01-18","objectID":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/:3:0","tags":["linux","bash","commands"],"title":"[Linux] Búsquedas por la terminal","uri":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/"},{"categories":null,"content":"find Es el más conocido y tiene tropocientas opciones y combinaciones posibles, pero aquí nos vamos a quedar con lo más práctico. Su sintaxis básica es find [options] [path...] [expression] ","date":"2022-01-18","objectID":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/:4:0","tags":["linux","bash","commands"],"title":"[Linux] Búsquedas por la terminal","uri":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/"},{"categories":null,"content":"Buscar directorios o carpetas find /home/linuxize -type d -name documents ","date":"2022-01-18","objectID":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/:4:1","tags":["linux","bash","commands"],"title":"[Linux] Búsquedas por la terminal","uri":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/"},{"categories":null,"content":"Buscar ficheros por nombre find /home/user -type f -name document.pdf ## Para buscar en el mismo directorio donde nos encontramos find . -type f -name document.pdf ## Busquedas sin distincion de mayusculas y minusculas find /home/user -type f -iname document.pdf ","date":"2022-01-18","objectID":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/:4:2","tags":["linux","bash","commands"],"title":"[Linux] Búsquedas por la terminal","uri":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/"},{"categories":null,"content":"Buscar ficheros por extensión find /home/user -type f -name '*.pdf' ## Lo contrario de lo anterior find /home/user -type f -not -name '*.pdf' Tenemos muchas más opciones como buscar recursivamente, por tamaño, fecha de modificación, permisos, usuario, etc. ","date":"2022-01-18","objectID":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/:4:3","tags":["linux","bash","commands"],"title":"[Linux] Búsquedas por la terminal","uri":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/"},{"categories":null,"content":"fd Se auto define como una alternativa simple, rápida, user-friendly… y tiene toda la razón, para buscar solo tenemos que hacer fd document ","date":"2022-01-18","objectID":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/:5:0","tags":["linux","bash","commands"],"title":"[Linux] Búsquedas por la terminal","uri":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/"},{"categories":null,"content":"ag o The Silver Searcher Esta alternativa también es muy rápida y al igual que la anterior buscar es simplemente escribir lo siguiente ag docu ","date":"2022-01-18","objectID":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/:6:0","tags":["linux","bash","commands"],"title":"[Linux] Búsquedas por la terminal","uri":"/2022/01/linux-b%C3%BAsquedas-por-la-terminal/"},{"categories":null,"content":"Esta operación tan básica no puede faltar en cualquier editor, y en Vim (realmente uso Neovim) me resulta muy fácil hacerla. ","date":"2021-10-24","objectID":"/2021/10/vim-b%C3%BAsquedas-y-reemplazo/:0:0","tags":["vim"],"title":"[Vim] Búsquedas  y Reemplazo","uri":"/2021/10/vim-b%C3%BAsquedas-y-reemplazo/"},{"categories":null,"content":"Forma 1 Normalmente lo que me suele pasar es que mientras estoy escribiendo o programando, me encuentro con la palabra que quiero sustituir y directamente hacer el cambio. Para esto, estando en el modo Normal y con el cursor encima de la palabra Pulsamos la tecla * Escribimos ciw (change inner word) y seguidamente la palabra que queramos Pulsamos Esc Con la tecla n nos movemos a la siguiente ocurrencia y para repetir lo anterior pulsamos . ","date":"2021-10-24","objectID":"/2021/10/vim-b%C3%BAsquedas-y-reemplazo/:1:0","tags":["vim"],"title":"[Vim] Búsquedas  y Reemplazo","uri":"/2021/10/vim-b%C3%BAsquedas-y-reemplazo/"},{"categories":null,"content":"Forma 2 Si lo que quiero es sustituir todas las coincidencias de la palabra que busco, lo hago con el comando :substitute (:s). La forma de construir las búsquedas con este comando es :[range]s/{pattern}/{string}/[flags] [count] Este comando busca en cada línea del rango ([range]) el patrón ({pattern}) especificado, y lo reemplaza por la cadena ({string}). El contador ([count]) es un entero positivo que multiplica el número de veces la ejecución del comando. Si no indicamos [range] ni [count] sólo reemplazará en la línea actual. Como lo que busco es buscar y reemplazar en todo el fichero :%s/foo/bar/g Si queremos tener un mensaje de confirmación en cada sustitución :%s/foo/bar/gc Para ignorar el case sensitivity (la sensibilidad de mayúsculas y minúsculas) :%s/foo/bar/gi ","date":"2021-10-24","objectID":"/2021/10/vim-b%C3%BAsquedas-y-reemplazo/:2:0","tags":["vim"],"title":"[Vim] Búsquedas  y Reemplazo","uri":"/2021/10/vim-b%C3%BAsquedas-y-reemplazo/"},{"categories":null,"content":"Uniendo estas dos formas Para rematar la jugada vamos a unir estas dos formas de búsqueda-sustitución en un comando y así ser más rápidos. En nuestro fichero de configuración de Vim o de Neovim añadimos lo siguiente nnoremap \u003cLeader\u003es :%s/\\\u003c\u003cC-r\u003e\u003cC-w\u003e\\\u003e//g\u003cLeft\u003e\u003cLeft\u003e Ahora pulsando la tecla \u003cLeader\u003e (por defecto en Vim es \\) + s, tendremos directamente la búsqueda realizada y solo tenemos que escribir el reemplazo. ","date":"2021-10-24","objectID":"/2021/10/vim-b%C3%BAsquedas-y-reemplazo/:3:0","tags":["vim"],"title":"[Vim] Búsquedas  y Reemplazo","uri":"/2021/10/vim-b%C3%BAsquedas-y-reemplazo/"},{"categories":null,"content":"Reemplazar una palabra con texto copiado Otra operación que de vez en cuando me pasa, es precisamente lo que indica el título, copio una palabra y la quiero sustituir por otra. Copio la palabra con yiw Me muevo a la palabra que quiero sustituir y pulso viwp ","date":"2021-10-24","objectID":"/2021/10/vim-b%C3%BAsquedas-y-reemplazo/:4:0","tags":["vim"],"title":"[Vim] Búsquedas  y Reemplazo","uri":"/2021/10/vim-b%C3%BAsquedas-y-reemplazo/"},{"categories":null,"content":"Referencias Find and Replace in Vim / Vi Search and replace the word under the cursor Replace a word with yanked text ","date":"2021-10-24","objectID":"/2021/10/vim-b%C3%BAsquedas-y-reemplazo/:5:0","tags":["vim"],"title":"[Vim] Búsquedas  y Reemplazo","uri":"/2021/10/vim-b%C3%BAsquedas-y-reemplazo/"},{"categories":null,"content":"Hace tiempo que llevo escuchando las bondades de los teclados mecánicos de la marca Keychron, y como necesitaba uno adquirí el modelo K3. En la parte trasera hay dos botones, con los que podemos elegir si estamos usando cable o bluetooh, mac o windows, pero uso GNU/Linux por lo que las teclas multimedia no funcionan de forma correcta. Los teclados Keychron en Linux usan el driver hid_apple, el cual por defecto usa las teclas F como las multimedia y necesitamos pulsar Fn + tecla para usar el F1 y sus consecutivas. Para cambiar esto hay que cambiar el parámetro fnmode del módulo del kernel hid_apple. Según la documentación, 0 = disabled: Disable the ‘fn’ key. Pressing ‘fn’+‘F8’ will behave like you only press ‘F8’ 1 = fkeyslast: Function keys are used as last key. Pressing ‘F8’ key will act as a special key. Pressing ‘fn’+‘F8’ will behave like a F8. 2 = fkeysfirst: Function keys are used as first key. Pressing ‘F8’ key will behave like a F8. Pressing ‘fn’+‘F8’ will act as special key (play/pause). Vamos a establecer un valor para testear la configuración que mejor se adapte # cambia \u003cvalue\u003e por 0, 1 o 2 echo \u003cvalue\u003e | sudo tee /sys/module/hid_apple/parameters/fnmode Personalmente el valor que le he dado es 2, y como ahora quiero hacer esto algo permenente voy a realizar los siguientes pasos: Creamos el fichero hid_apple.conf sudo touch /etc/modprobe.d/hid_apple.conf Añadimos a ese fichero la línea options hid_apple fnmode=\u003cvalue\u003e echo \"options hid_apple fnmode=2\" | sudo tee /etc/modprobe.d/hid_apple.conf Reconstruimos initramfs Arch: sudo mkinitcpio -P Ubuntu: sudo update-initramfs -u Reiniciamos Después de esto la configuración será permenente. Update Referencias: https://douglastofoli.dev/en/posts/keychron-linux/ https://gist.github.com/andrebrait/961cefe730f4a2c41f57911e6195e444 ","date":"2021-09-07","objectID":"/2021/09/linux-teclado-keychron-y-teclas-multimedia/:0:0","tags":["linux"],"title":"[Linux] Teclado Keychron y teclas multimedia","uri":"/2021/09/linux-teclado-keychron-y-teclas-multimedia/"},{"categories":null,"content":"Ya sabemos que Vim es una herramienta con mucha potencia (y con una curva de aprendizaje bastante pronunciada) y a la vez liviana, incluso cuando cargamos plugins. Es por esto mismo por lo que lo uso para hacer limpieza de grandes archivos, y en esta ocasión necesitaba eliminar las líneas de un fichero si las mismas contiene un patrón. Tenemos varias formas de hacerlo, una de ellas es buscar en todo el documento la palabra o patrón y directamente eliminar las líneas :g /palabra/d Lo inverso sería :g!/palabra/d Esta forma de borrado inverso (borramos las líneas que no contienen la palabra) también podemos hacerlo así :v /palabra/d Esto quiere decir que :v es el opuesto de :g. Aprovechando este tema dejo un bonus, para eliminar todas las líneas en blanco escribimos :g/^$/d o :g/^\\s*$/d ","date":"2021-05-29","objectID":"/2021/05/vim-eliminar-l%C3%ADneas-siguiendo-un-patr%C3%B3n/:0:0","tags":["vim"],"title":"[Vim] Eliminar líneas siguiendo un patrón","uri":"/2021/05/vim-eliminar-l%C3%ADneas-siguiendo-un-patr%C3%B3n/"},{"categories":null,"content":"Una de las formas más seguras y eficientes de desarrollar proyectos en Python es usando entornos virtuales. Podemos hacer todo tipo de perrerías y si no va bien simplemente borramos una carpeta y volvemos a empezar. Aunque existen varios métodos para tener entornos virtuales, aquí solo vamos a hacerlo de la forma más sencilla posible. Sabiendo que estamos usando Python 3 (verifica la versión por defecto conpython --version y si no es la 3, has de usar python3 --version) y estamos en la carpeta de nuestro proyecto, ejecutamos python -m venv venv en donde el último parámetro venv es el nombre que va a recibir la carpeta que va a contener los archivos de nuestro entorno virtual (instalación de librerías, etc.). Ahora necesitamos activarlo source venv/bin/activate Una vez hayamos terminado de trabajar en nuestro proyecto, desactivamos el entorno con un simple deactivate Instalación de dependencias Una vez tenemos el entorno virtual creado y activado, pasamos a instalar dependencias con pip install \u003cpaquete\u003e Sin embargo, si tenemos un fichero requirements.txt las podemos instalar con pip install -r requirements.txt ","date":"2021-04-10","objectID":"/2021/04/python-crear-entornos-virtuales-en-python-3/:0:0","tags":["python"],"title":"[Python] Crear entornos virtuales en Python 3","uri":"/2021/04/python-crear-entornos-virtuales-en-python-3/"},{"categories":null,"content":"Aunque el título suene engañoso y a Bash le demos este horrible adjetivo que tienen algunas personas, el caso al que me refiero con insensible es que no distinga entre mayúsculas y minúsculas. Cuando uso el comando cd para moverme entre directorios (aunque cada día uso más ranger, me resultaba ciertamente molesto estar pulsando la tecla shift cada vez que me encontraba con una carpeta o archivo con la primera letra en mayúsculas. Necesitaba agilizar ese proceso y esta opción de autocompletado la podemos hacer efectiva para nuestro usuario actual # Copiamos el contenido de /etc/inputrc a nuestra home en caso de que no exista if [ ! -a ~/.inputrc ]; then echo '$include /etc/inputrc' \u003e ~/.inputrc; fi # Añadimos a ~/.inputrc el autocompletado insensible echo 'set completion-ignore-case On' \u003e\u003e ~/.inputrc o para todos los usuarios # Añadimos a /etc/inputrc el autocompletado insensible echo 'set completion-ignore-case On' \u003e\u003e /etc/inputrc # Si nos estamos con root usad este comando echo 'set completion-ignore-case On' | sudo tee -a /etc/inputrc Otra opción es usar el siguiente script: bash-sensible. El cual hace que la experiencia con Bash sea un poco más sensata por defecto. ","date":"2021-03-29","objectID":"/2021/03/linux-autocompletado-insensible-en-bash/:0:0","tags":["linux","bash"],"title":"[Linux] Autocompletado insensible en Bash","uri":"/2021/03/linux-autocompletado-insensible-en-bash/"},{"categories":null,"content":"Sigo en mi ruta por ir pasando tareas que hacía en Matlab, y una de las habituales que podemos encontrarnos es una regresión lineal o una no lineal. Mejor no entro en el debate del porqué no se usa Python + Numpy + otras librerías en el ámbito académico, de modo que me limito a describir como poder hacer estas regresiones con Numpy. Supongamos que tenemos los datos en dos arrays (ya sea cargando los datos de un csv, un archivo de texto o cualquier otra forma), lo único que tenemos que hacer es especificar el grado del polinomio con el que queremos hacer el ajuste. Un ejemplo puede ser el siguiente código, donde cargamos Numpy renombrándolo a np, tenemos los datos en listas y el modelo de regresión lineal lo tenemos con el método polyfit (en este especificamos el grado del polinomio). Como podéis observar hay un método llamado poly1d, este método lo que hace es construir el polinomio de una dimensión con los coeficientes que ha calculado polyfit. Por último con linspace creamos un array que va de 1 a 5 tomando 100 números (esto lo hago para luego hacer la gráfica). import numpy as np # Variables con nuestros datos a analizar x = [1,2,3,4,5] y = [10,20,30,40,50] # Modelo de Regresion Lineal. Especificamos que es de grado 1 regmodel = np.poly1d(np.polyfit(x,y,1)) regline = np.linspace(1,5,100) Si queremos ver los coeficientes del polinomio, podemos hacer z = np.polyfit(x, y, 1) print(\"\\nCoeficientes del Polinomio:\\n\", z) También estaría bien saber el grado de lo buena que es nuestra regresión, el R cuadrado ( $R^2$ ). Para esto llamamos a la librería sklearn, import numpy as np from sklearn.metrics import r2_score # Mostramos el R cuadrado print(r2_score(y,regmodel(x))) Por último nos quedaría representar los datos junto con la regresión, así que cargamos matplotlib y ploteamos: import matplotlib.pyplot as plt # Representamos los datos con un Scatter # y la regresion con un plot plt.scatter(x,y) plt.plot(regline, regmodel(regline)) plt.show() A partir de estas indicaciones podemos crear nuestra propia plantilla para representar datos junto con la regresión (lineal o no lineal), y así sólo tenemos que aplicarla a un .csv o al conjunto de datos que tengamos. ","date":"2021-02-08","objectID":"/2021/02/python-regresi%C3%B3n-lineal/:0:0","tags":["python","data science","numpy"],"title":"[Python] Regresión Lineal","uri":"/2021/02/python-regresi%C3%B3n-lineal/"},{"categories":null,"content":"Hasta no hace mucho era común encontrarse por las redes archivos comprimidos en varias partes, de este modo carpetas, imagenes, etc. de varios gigabytes se podían compartir de forma más fácil. Como si fuera cosa del pasado, recientemente he tenido varias situaciones de diversa índole en las que he tenido que recurrir a esta solución. Para que no caiga en el olvido, comparto como he hecho esta operación. El «algoritmo» sería: primero comprimir los archivos con tar y luego partirlos con split. tar cz fichero_1 fichero_2 | split -b 1024MiB - ficheros.tgz_ Este comando nos comprime los ficheros fichero1 y fichero2 (pueden ser ficheros o carpetas), después los parte en trozos de 1024MiB y además les añade un sufijo de letras (la secuencia es: aa, ab, ac, …), es decir, el resultado sería: ficheros.tgz_aa ficheros.tgz_ab ficheros.tgz_ac . . . Para descomprimir: cat ficheros.tgz_* | tar xz En caso de tener sólo un archivo, podemos usar gzip: gzip -c fichero | split -b 1024MiB - fichero_part.gz_ Y para descomprimir: cat fichero_part.gz_* | gunzip -c \u003e fichero Como indica la documentación de split, en el argumento del tamaño, -b, las unidades son: K,M,G,T,P,E,Z,Y para potencias de 1024 o KB,MB,... para potencias de 1000. Además hay una equivalencia entre las formas KiB=K, MiB=M, etc. Otro argumento interesante de split es poder cambiar el sufijo, particularmente me gusta más que sea numérico, de modo que añado -d. Así si quiero partir varios ficheros en trozos de 500MiB y que el sufijo sea con números, tar cz fichero1 fichero2 | split -d -b 500M - ficheros.tgz_ Espero que el post sea de ayuda 😉 ","date":"2020-12-02","objectID":"/2020/12/linux-comprimir-y-partir-archivos/:0:0","tags":["linux","commands","tips"],"title":"[Linux] Comprimir y partir archivos","uri":"/2020/12/linux-comprimir-y-partir-archivos/"},{"categories":null,"content":"En ingeniería (y en el ámbito científico en general) es de sobra conocido Matlab para resolver ecuaciones, hacer modelado, simulaciones, etc. Pero ya sea por el precio, forma de trabajar, filosofía de software o cualquier otra razón no queramos usarlo y busquemos un reemplazo. Podemos optar por usar GNU Octave, pero yo me inclino por Python + Jupyter. Así pues, vamos a ver como podemos resolver ecuaciones, ecuaciones cuadráticas, sistemas de ecuaciones lineales y una pequeña introducción al cálculo simbólico. ","date":"2020-11-09","objectID":"/2020/11/python-resolver-ecuaciones-y-sistemas-de-ecuaciones/:0:0","tags":["python","math"],"title":"[Python] Resolver ecuaciones y sistemas de ecuaciones","uri":"/2020/11/python-resolver-ecuaciones-y-sistemas-de-ecuaciones/"},{"categories":null,"content":"Ecuaciones de segundo grado Archiconocidas ecuaciones y una forma de resolverlas es con la librería cmath, la cual nos permite trabajar con funciones para números complejos. Entonces si tenemos \\[ ax^2 + bx + c = 0 \\] donde $ a $, $ b $ y $ c $ son números reales y $ a \\neq 0 $. Para resolverla lo haremos mediante \\[ x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} \\] de modo que el script sería el siguiente: import cmath a = 20 b = 25 c = 5 # Calculamos el discriminante d = (b**2) - (4*a*c) # Buscamos las dos soluciones sol1 = (-b-cmath.sqrt(d))/(2*a) sol2 = (-b+cmath.sqrt(d))/(2*a) # Sacamos por pantalla las soluciones print('Las soluciones son {0} y {1}'.format(sol1,sol2)) ","date":"2020-11-09","objectID":"/2020/11/python-resolver-ecuaciones-y-sistemas-de-ecuaciones/:1:0","tags":["python","math"],"title":"[Python] Resolver ecuaciones y sistemas de ecuaciones","uri":"/2020/11/python-resolver-ecuaciones-y-sistemas-de-ecuaciones/"},{"categories":null,"content":"Sistemas de ecuaciones lineales Un ejemplo puede ser el siguiente 4x + 3y = 20 -5x + 9y = 26 Para resolver este tipo de sistemas vamos a usar matrices, que para resolverlos se representan en la forma $ A X = B $, es decir: \\[ A = \\begin{pmatrix} 4 \u0026 3 \\\\ -5 \u0026 9 \\end{pmatrix} \\] \\[ X = \\begin{pmatrix} x \\\\ y \\end{pmatrix} \\] \\[ B = \\begin{pmatrix} 20 \\\\ 26 \\end{pmatrix} \\] Por tanto, para saber los valores de $ x $ e $ y $ efectuamos la siguiente operación: \\[ X = A^{-1} B \\] Para traducir todo esto a Python vamos a usar la librería NumPy, ya que nos ofrece los métodos inv() y dot(), con los que hacer la inversa y la operación punto de las matrices. import numpy as np # Introducimos los coeficientes m_list = [[4, 3], [-5, 9]] A = np.array(m_list) # Hacemos la inversa inv_A = np.linalg.inv(A) # Operamos B = np.array([20, 26]) X = np.linalg.inv(A).dot(B) # Sacamos la solución print(X) Una alternativa es usar el método solve() que directamente nos busca la solución al sistema lineal: A = np.array([[4, 3], [-5, 9]]) B = np.array([20, 26]) X = np.linalg.solve(A,B) print(X) ","date":"2020-11-09","objectID":"/2020/11/python-resolver-ecuaciones-y-sistemas-de-ecuaciones/:2:0","tags":["python","math"],"title":"[Python] Resolver ecuaciones y sistemas de ecuaciones","uri":"/2020/11/python-resolver-ecuaciones-y-sistemas-de-ecuaciones/"},{"categories":null,"content":"Cálculo simbólico Si hemos usado Matlab, es sabido que podemos definir variables como simbólicas, pues en Python existe una magnifica librería, SymPy, que nos permite hacer esto y resolver ecuaciones de una forma muy fácil. Siguiendo con el ejemplo del anterior del sistema de ecuaciones, resolverlo con SymPy sería así: from sympy import symbols, Eq, solve # Declaramos las variables x, y = symbols('x y') # Definimos las ecuaciones eq1 = Eq(4*x + 3*y - 20, 0) eq2 = Eq(-5*x + 9*x -26, 0) # Resolvemos solve((eq1,eq2), (x, y)) ","date":"2020-11-09","objectID":"/2020/11/python-resolver-ecuaciones-y-sistemas-de-ecuaciones/:3:0","tags":["python","math"],"title":"[Python] Resolver ecuaciones y sistemas de ecuaciones","uri":"/2020/11/python-resolver-ecuaciones-y-sistemas-de-ecuaciones/"},{"categories":null,"content":"Conclusiones Tenemos multitud de opciones para resolver ecuaciones y sistemas de ecuaciones, según sea nuestro problema o el entorno en el que estemos trabajando podemos usar la librería. Sin duda SymPy es lo mas parecido a los que vienen de Matlab, y aunque solo haya realizado un pequeño ejemplo tiene una gran comunidad con la que encontrar soluciones en este campo. ","date":"2020-11-09","objectID":"/2020/11/python-resolver-ecuaciones-y-sistemas-de-ecuaciones/:4:0","tags":["python","math"],"title":"[Python] Resolver ecuaciones y sistemas de ecuaciones","uri":"/2020/11/python-resolver-ecuaciones-y-sistemas-de-ecuaciones/"},{"categories":null,"content":"En esta página voy a ir almacenando pequeños trucos que me voy encontrando, atajos de teclado útiles en ciertas ocasiones o simplemente cosas que no quiero olvidar. ","date":"2020-10-18","objectID":"/pages/resources/vim-notas-trucos/:0:0","tags":["vim"],"title":"[LaTeX] Notas y Trucos","uri":"/pages/resources/vim-notas-trucos/"},{"categories":null,"content":"Búsqueda insensible Por defecto viene desactivada, la podemos activar para que todas las búsquedas sean insensibles, pero la forma más rápida es agregar al final de nuestra búsqueda \\c. Por ejemplo, si estamos buscando en nuestro documento la palabra linux: /linux\\c ","date":"2020-10-18","objectID":"/pages/resources/vim-notas-trucos/:0:1","tags":["vim"],"title":"[LaTeX] Notas y Trucos","uri":"/pages/resources/vim-notas-trucos/"},{"categories":null,"content":"Ya hemos hecho algunas cositas interesantes con los contenedores de Docker y llega un momento en que necesitamos monitorizarlos, saber que está pasando, los recursos que consume o por qué no funciona correctamente. Para ello Docker nos brinda tres comandos: logs, top y stats. ","date":"2020-09-15","objectID":"/2020/09/docker-monitorizar-contenedores/:0:0","tags":["docker"],"title":"[Docker] Monitorizar contenedores","uri":"/2020/09/docker-monitorizar-contenedores/"},{"categories":null,"content":"docker logs Como os podéis imaginar con docker logs nos va a mostrar los logs del contenedor que queramos. La sintaxis sería: docker logs \u003cID o nombre contenedor\u003e Si queremos seguir la salida que va mostrando: docker logs -f \u003cID o nombre contenedor\u003e O mostrar las últimas diez salidas: docker logs --tail 10 \u003cID o nombre contenedor\u003e ","date":"2020-09-15","objectID":"/2020/09/docker-monitorizar-contenedores/:0:1","tags":["docker"],"title":"[Docker] Monitorizar contenedores","uri":"/2020/09/docker-monitorizar-contenedores/"},{"categories":null,"content":"docker top Mostramos los procesos que están corriendo de un contenedor: docker top \u003cID o nombre contenedor\u003e ","date":"2020-09-15","objectID":"/2020/09/docker-monitorizar-contenedores/:0:2","tags":["docker"],"title":"[Docker] Monitorizar contenedores","uri":"/2020/09/docker-monitorizar-contenedores/"},{"categories":null,"content":"docker stats Nos muestra las estadísticas del flujo de recursos de un contenedor o de varios contenedores. Esto es, el uso de CPU, memoria, trafico de red y de disco. docker stats \u003cIDs o nombre contenedores\u003e Si queremos ver todos los contenedores: docker stats -a Podemos usar la opción --format para sacar la información que queramos de la forma que nos guste, por ejemplo: docker stats --format \"{{.Name}}\\t{{.CPUPerc}}\" \u003cIDs o nombre contenedorres\u003e La salida de este comando es la monitorización de solo el porcentaje de CPU a los contenedores especificados. ","date":"2020-09-15","objectID":"/2020/09/docker-monitorizar-contenedores/:0:3","tags":["docker"],"title":"[Docker] Monitorizar contenedores","uri":"/2020/09/docker-monitorizar-contenedores/"},{"categories":null,"content":"Usar un contenedor Existen contenedores que se encargan de recoger las métricas y usos de otros contenedores, algunos de estos son cAdvisor o Prometheus (esta es ya una solución cuando tenemos una infraestructura importante). Cualquiera de estas opciones es buena si el fin es que todo funcione correctamente 😄 ","date":"2020-09-15","objectID":"/2020/09/docker-monitorizar-contenedores/:0:4","tags":["docker"],"title":"[Docker] Monitorizar contenedores","uri":"/2020/09/docker-monitorizar-contenedores/"},{"categories":null,"content":"Cuando llevamos algún tiempo usando Docker surge una nueva necesidad: actualizar nuestros servicios. Tradicionalmente esto siempre lo hacíamos cuando actualizábamos el sistema, con el consecuente problema de si algún paquete queríamos que conservara alguna versión en particular y demás títeres. Actualizar los contenedores es realmente fácil, solo hay que asegurarse de donde estamos guardando los datos (me refiero a aquello de los volúmenes). Procedemos de la siguiente manera: Un ejemplo con mysql es el siguiente: docker pull mysql docker stop my-mysql-container docker rm my-mysql-container docker run --name=my-mysql-container --restart=always \\ -e MYSQL_ROOT_PASSWORD=mypwd -v /my/data/dir:/var/lib/mysql -d mysql Si estamos usando docker-compose procedemos de la misma manera: docker-compose pull docker-compose stop docker-compose up -d Hay que tener especial cuidado con los volúmenes que tengan asociados los contenedores, pero aparte de eso es coser y cantar. ","date":"2020-09-08","objectID":"/2020/09/docker-actualizar-nuestros-contenedores/:0:0","tags":["docker"],"title":"[Docker] Actualizar nuestros contenedores","uri":"/2020/09/docker-actualizar-nuestros-contenedores/"},{"categories":null,"content":"En mi día a día uso Manjaro con XFCE, y también cierto software para escuchar música (Spotify). Para instalarlo tuve que hacerlo por los repositorios AUR, pero en una reciente actualización cual fue mi sorpresa al ver este error: ERROR: One or more PGP signatures could not be verified!. Los que usamos Arch y sus derivados estamos siempre con el dilema de los repositorios AUR, proveen una gran cantidad de software pero, ¿a qué precio? Bueno, la cuestión aquí es resolver el problema de las claves PGP, en concreto las de Spotify. Primero nos dirigimos a la sección de descargas de Spotify, y buscamos la parte donde especifica la instalación via línea de comandos (Install via command line). Solo nos ofrece la instalación por Snap y si usamos Debian / Ubuntu. No es ningún problema, buscamos la línea curl -sS https://download.spotify.com/debian/pubkey_0D811D58.gpg | sudo apt-key add - , y la adaptamos a nuestro sistema Manjaro/Arch: curl -sS https://download.spotify.com/debian/pubkey_0D811D58.gpg | gpg --import - Ahora solo queda instalarlo pamac build spotify Con esto ya queda solucionado. Aunque lo haya realizado para Spotify, esta solución se puede extrapolar a otras Apps con el mismo problema. ","date":"2020-07-21","objectID":"/2020/07/manjaro/arch-error-al-verificar-claves-pgp-en-aur/:0:0","tags":["linux"],"title":"[Manjaro/Arch] Error al verificar claves PGP en AUR","uri":"/2020/07/manjaro/arch-error-al-verificar-claves-pgp-en-aur/"},{"categories":null,"content":"El error que me he encontrado en alguna ocasión esporádica en Proxmox es que no podía parar un contenedor (en concreto un lxc) ni tampoco apagarlo, por lo que no podía apagar el sistema. De hecho, al entrar por SSH al Proxmox también obtenía el mismo error, o sea era imposible apagarlo de la forma correcta. Después de probar diversos comandos, soluciones, navegar por foros y documentación, encontré la solución con el comando lxc. Seguí los pasos que describo a continuación: lxc-ls --fancy lxc-stop \u003cnombre/numero de la maquina o contenedor\u003e Obviamente estos comandos los ejecuté por SSH. He leído varias razones por las que se puede dar esto, y creo que la mas plausible según el uso que le he dado al contenedor en cuestión, es que se quede un proceso colgado o abortado. De modo que, !revisad los procesos! ","date":"2020-07-05","objectID":"/2020/07/proxmox-soluci%C3%B3n-al-error-cant-lock-file-/run/lock/lxc/pve-config-xxx.lock/:0:0","tags":["proxmox"],"title":"[Proxmox] Solución al error: can't lock file '/run/lock/lxc/pve-config-xxx.lock'","uri":"/2020/07/proxmox-soluci%C3%B3n-al-error-cant-lock-file-/run/lock/lxc/pve-config-xxx.lock/"},{"categories":null,"content":"Siguiendo con la dinámica del anterior post de Docker, voy a describir algunos comandos útiles que cuando comenzamos a usar contenedores nos van a ayudar a entenderlos y aprovechar mejor sus virtudes. ","date":"2020-06-15","objectID":"/2020/06/docker-comandos-%C3%BAtiles/:0:0","tags":["docker","tutorial"],"title":"[Docker] Comandos Útiles","uri":"/2020/06/docker-comandos-%C3%BAtiles/"},{"categories":null,"content":"Contenedor Interactivo La mejor forma de ver esto es con alguna distribución, por ejemplo Ubuntu. Lo que hacemos es crear un contenedor basado en Ubuntu y entrar dentro del mismo (opción -i). Además sacamos por pantalla la salida del contenedor (-t): docker run -it ubuntu # Entramos al contenedor y lanzamos bash docker run -it ubuntu bash Para salir del contenedor solo hay que ejecutar exit, lo cual también parará el propio contenedor. OjO! Cada vez que ejecutamos un docker run estamos creando un contenedor nuevo. Dado que al hacer exit lo hemos parado, podemos volver a usarlo con docker start -i \u003cID o nombre del contenedor\u003e. ","date":"2020-06-15","objectID":"/2020/06/docker-comandos-%C3%BAtiles/:0:1","tags":["docker","tutorial"],"title":"[Docker] Comandos Útiles","uri":"/2020/06/docker-comandos-%C3%BAtiles/"},{"categories":null,"content":"Borrar contenedor al paralo Si le pasamos el parámetro --rm borrará el contenedor una vez lo hayamos parado: docker run -it --rm --name docker_ubuntu ubuntu Este comando arranca un contenedor interactivo de la imagen de ubuntu con el nombre docker_ubuntu, y además lo borrará una vez lo paremos. ","date":"2020-06-15","objectID":"/2020/06/docker-comandos-%C3%BAtiles/:0:2","tags":["docker","tutorial"],"title":"[Docker] Comandos Útiles","uri":"/2020/06/docker-comandos-%C3%BAtiles/"},{"categories":null,"content":"Contenedor en Background/Segundo Plano Arrancamos un contenedor (e.g. de php) y lo dejamos en segundo plano para no tener abierta la terminal: docker run -d php ","date":"2020-06-15","objectID":"/2020/06/docker-comandos-%C3%BAtiles/:0:3","tags":["docker","tutorial"],"title":"[Docker] Comandos Útiles","uri":"/2020/06/docker-comandos-%C3%BAtiles/"},{"categories":null,"content":"Darle un Nombre al Contenedor Para no tener que estar mirando el ID o el nombre random que le da Docker a los contenedores cada vez que creamos uno, vamos a pasarle la opción --name al crearlo: docker run -it --name docker_ubuntu ubuntu ","date":"2020-06-15","objectID":"/2020/06/docker-comandos-%C3%BAtiles/:0:4","tags":["docker","tutorial"],"title":"[Docker] Comandos Útiles","uri":"/2020/06/docker-comandos-%C3%BAtiles/"},{"categories":null,"content":"Ejecutar Comandos Teniendo un contenedor en background, por ejemplo un Ubuntu, le podemos pasar comandos con: docker exec docker_ubuntu echo Hola Mundo La sintaxis sería: docker exec \u003cID o nombre contenedor\u003e \u003cComando a ejecutar\u003e. Hay contenedores que su modo interactivo es entrar a un intérprete de comandos (php, python, etc.), y en caso de que quisieramos hacer algún cambio en los mismo podemos usar exec. Suponiendo que tenemos un contenedor de php corriendo (docker run -it --name docker_php php): docker exec -it docker_php bash Con estos comandos ya podemos jugar mejor y comprender como funcionan los contenedores además de aprovecharlos no solo para correr un microservicio o un framework. ","date":"2020-06-15","objectID":"/2020/06/docker-comandos-%C3%BAtiles/:0:5","tags":["docker","tutorial"],"title":"[Docker] Comandos Útiles","uri":"/2020/06/docker-comandos-%C3%BAtiles/"},{"categories":null,"content":"En el mundo de los que nos gusta el cacharreo Docker se ha convertido en una herramienta casi obligada, nos evitamos reinstalaciones, «formateos» y demás engorrros con sus correspondientes pérdidas de tiempo. Se ha escrito mucho sobre Docker, lo que pretendo con esta pequeña introducción es dejar claras algunas deficiones, y ofrecer una serie de comandos básicos. ","date":"2020-05-19","objectID":"/2020/05/docker-comandos-b%C3%A1sico/:0:0","tags":["docker","tutorial"],"title":"[Docker] Comandos  Básico","uri":"/2020/05/docker-comandos-b%C3%A1sico/"},{"categories":null,"content":"Deficiones ","date":"2020-05-19","objectID":"/2020/05/docker-comandos-b%C3%A1sico/:1:0","tags":["docker","tutorial"],"title":"[Docker] Comandos  Básico","uri":"/2020/05/docker-comandos-b%C3%A1sico/"},{"categories":null,"content":"Docker Es como un gestor de paquetes tipo Snap o AppImage. ","date":"2020-05-19","objectID":"/2020/05/docker-comandos-b%C3%A1sico/:1:1","tags":["docker","tutorial"],"title":"[Docker] Comandos  Básico","uri":"/2020/05/docker-comandos-b%C3%A1sico/"},{"categories":null,"content":"Imagen Es un paquete con todo lo necesario para ejecutar una aplicación o servicio. Es como un ejecutable. ","date":"2020-05-19","objectID":"/2020/05/docker-comandos-b%C3%A1sico/:1:2","tags":["docker","tutorial"],"title":"[Docker] Comandos  Básico","uri":"/2020/05/docker-comandos-b%C3%A1sico/"},{"categories":null,"content":"Contenedor Es la imagen en funcionamiento. Es cada una de las instancias o procesos que hay en funcionamiento. Instancia: es una copia de una versión ejecutable del programa que ha sido escrito en la memoria del computador. Utiliza y comparte el SO de la máquina con otras aplicaciones y con otros contenedores. Al detener el contenedor este se queda en el equipo. ","date":"2020-05-19","objectID":"/2020/05/docker-comandos-b%C3%A1sico/:1:3","tags":["docker","tutorial"],"title":"[Docker] Comandos  Básico","uri":"/2020/05/docker-comandos-b%C3%A1sico/"},{"categories":null,"content":"Comandos ","date":"2020-05-19","objectID":"/2020/05/docker-comandos-b%C3%A1sico/:2:0","tags":["docker","tutorial"],"title":"[Docker] Comandos  Básico","uri":"/2020/05/docker-comandos-b%C3%A1sico/"},{"categories":null,"content":"Imágenes Descargar imágenes: docker pull \u003cnombre imagen o repositorio\u003e Ver imagenes descargadas: docker image ls # Equivalente docker images Ver imagenes intermedias: docker image ls -a Ver los numeros de identificacion, ID: docker image ls -q Borrar las imagenes que no estamos utilizando: docker image prune Borrar una o varias imagenes: docker image rm \u003cnombre imagen\u003e O también con: docker rmi \u003cnombre imagen\u003e ","date":"2020-05-19","objectID":"/2020/05/docker-comandos-b%C3%A1sico/:2:1","tags":["docker","tutorial"],"title":"[Docker] Comandos  Básico","uri":"/2020/05/docker-comandos-b%C3%A1sico/"},{"categories":null,"content":"Contenedores Iniciar un contenedor: docker run hello-world Ver los contenedores que tenemos: docker ps -a Para un contenedor: docker stop \u003cnombre o ID\u003e Iniciar de nuevo: docker start \u003cnombre o ID\u003e Reiniciar: docker restart \u003cnombre o ID\u003e Matando contenedores: docker kill \u003cnombre o ID\u003e Borrar contenedor: docker rm \u003cnombre contenedor\u003e Borrar todos los contenedores que estén parados: docker container prune Ver el proceso del docker: docker top \u003cnombre contenedor\u003e Ver estadisticas: docker stats --no-stream \u003cnombre contenedor\u003e Lo paramos con Ctrl + c. ","date":"2020-05-19","objectID":"/2020/05/docker-comandos-b%C3%A1sico/:2:2","tags":["docker","tutorial"],"title":"[Docker] Comandos  Básico","uri":"/2020/05/docker-comandos-b%C3%A1sico/"},{"categories":null,"content":"Referencias Docker. Introducción y primeros pasos Post-installation steps for Linux | Docker Documentation Install Docker Engine on Debian | Docker Documentation Docker Hub ","date":"2020-05-19","objectID":"/2020/05/docker-comandos-b%C3%A1sico/:3:0","tags":["docker","tutorial"],"title":"[Docker] Comandos  Básico","uri":"/2020/05/docker-comandos-b%C3%A1sico/"},{"categories":null,"content":"Cuando nos iniciamos en el mundo GNU/Linux hay una de las tareas más comunes que puede llegar a ser un suplicio: editar archivos PDF. Para operaciones tan básicas como unir o cortar páginas, encriptar, etc. tenía que recurrir a alguna web que realizaban estos propósitos o resignarme a hacer alguna treta. Dado que me estoy empezando a manejar mejor con aplicaciones en CLI (por aquello de automatizar procesos), busqué soluciones de este tipo y me encontré con dos: PDFtk y Xpdf. Aparte de estas dos también buscaba una en la que pudiera hacer resaltado de texto, anotaciones, etc. y entonces me topé con Master PDF Editor, que incluso en su versión gratuita no le falta de nada. ","date":"2020-04-14","objectID":"/2020/04/linux-editar-modificar-pdfs/:0:0","tags":["linux","pdf"],"title":"[Linux] Editar y Modificar PDFs","uri":"/2020/04/linux-editar-modificar-pdfs/"},{"categories":null,"content":"PDFtk En más de una ocasión he tenido que unir varios PDF, unir páginas de distintos PDF, eliminar páginas… todo de forma recursiva. Así que eso de ir uno a uno sería una locura, mejor que PDFtk lo haga. Primero instalamos el paquete, que obviamente dependerá de la distribución que uséis: sudo apt install pdftk # Debian sudo pacman -S pdftk # Manjaro Voy a poner algunos comandos útiles. Unir varios PDF en un nuevo documento: pdftk in1.pdf in2.pdf in3.pdf cat output out123.pdf Lo anterior pero usando wildcards: pdftk *.pdf cat output out.pdf Eliminar la página 13 de in1.pdf y crear un documento nuevo: pdftk in1.pdf cat 1-12 14-end output out.pdf Seleccionar varias páginas de distintos PDF y crear uno nuevo: pdftk A=in1.pdf B=in2.pdf cat A1-7 B1-5 A8 output out.pdf Sacar un informe con los metadatos marcadores y etiquetas; pdftk in1.pdf dump_data output informe.txt Podemos encontrar más ejemplos en PDFtk Server Examples, como añadir marcas de agua, y nunca viene mal echar un vistazo al manual. ","date":"2020-04-14","objectID":"/2020/04/linux-editar-modificar-pdfs/:0:1","tags":["linux","pdf"],"title":"[Linux] Editar y Modificar PDFs","uri":"/2020/04/linux-editar-modificar-pdfs/"},{"categories":null,"content":"Xpdf Esta herramienta aunque es un visor (el cual ofrece algunas cosas interesantes), también puede realizar conversiones, extraer texto, extraer imágenes, analizar fuentes, extraer información, etc. Lo primero como siempre es instalar el paquete: sudo apt install xpdf # Debian sudo pacman -S xpdf # Manjaro Veamos algunos ejemplos: Extraer texto y guardarlo en un .odt o .txt: pdftotext in1.pdf out.odt pdftotext in1.pdf out.txt Extraer las imágenes y guardarlas en una carpeta: pdfimages -all in1.pdf /ruta/carpeta Ver la información del PDF: pdfinfo in1.pdf Esta herramienta trae algunas utilidades más que podemos ver en su página de soporte. ","date":"2020-04-14","objectID":"/2020/04/linux-editar-modificar-pdfs/:0:2","tags":["linux","pdf"],"title":"[Linux] Editar y Modificar PDFs","uri":"/2020/04/linux-editar-modificar-pdfs/"},{"categories":null,"content":"Master PDF Editor Sin duda una aplicación completa para todas esas operaciones de resaltado de texto, añadir flechas y otras figuras. ","date":"2020-04-14","objectID":"/2020/04/linux-editar-modificar-pdfs/:0:3","tags":["linux","pdf"],"title":"[Linux] Editar y Modificar PDFs","uri":"/2020/04/linux-editar-modificar-pdfs/"},{"categories":null,"content":"Herramientas Online De forma online existen multitud de herramientas para hacer las tareas descritas anteriormente. Las expongo ya que en alguna ocasión seguro que haremos uso de ellas, ya sea por necesidad o por simple curiosidad. Eso sí, no tendremos la misma libertad y versatilidad, estas webs nos hacen el «apaño» en ocasiones puntuales. Soda PDF iLove PDF Online OCR ","date":"2020-04-14","objectID":"/2020/04/linux-editar-modificar-pdfs/:0:4","tags":["linux","pdf"],"title":"[Linux] Editar y Modificar PDFs","uri":"/2020/04/linux-editar-modificar-pdfs/"},{"categories":null,"content":"Conclusiones Con estas tres herramientas cubrimos todas las necesidades que tengamos para manipular PDF, desde lo básico hasta manejar varios documentos a la vez, extraer información o crear scritps. Si además incluimos las herramientas online que nos pueden salvar de más de un apuro, el manejo de PDFs se queda en un juego de niñxs. ","date":"2020-04-14","objectID":"/2020/04/linux-editar-modificar-pdfs/:0:5","tags":["linux","pdf"],"title":"[Linux] Editar y Modificar PDFs","uri":"/2020/04/linux-editar-modificar-pdfs/"},{"categories":null,"content":"Desde que uso Markdown realizar documentos se ha convertido en una tarea realmente fácil y rápida. Es cierto que en formato RAW no lo podemos enviar de forma general, se vuelve necesario convertirlo a PDF. Y en esta tarea es donde entra en juego Pandoc, el cual es un conversor de documentos libre y de código abierto. Pandoc usa nuestro amado LaTeX para convertir a PDF, con lo que se convierte en una combinación perfecta y personalizable. ","date":"2020-02-17","objectID":"/2020/02/latex-pandoc-tutorial-basico/:0:0","tags":["latex","pandoc","tutorial"],"title":"[LaTeX/Pandoc] Tutorial Básico","uri":"/2020/02/latex-pandoc-tutorial-basico/"},{"categories":null,"content":"Instalación Dado que uso Manjaro pongo el comando para este, pero para las demás distribuciones habidas y por haber el comando es similar (según se use apt, yum, etc.): sudo pacman -S pandoc Para tener una completa integración instalamos los dos siguientes paquetes: sudo pacman -S pandoc-citeproc pandoc-crossref ","date":"2020-02-17","objectID":"/2020/02/latex-pandoc-tutorial-basico/:0:1","tags":["latex","pandoc","tutorial"],"title":"[LaTeX/Pandoc] Tutorial Básico","uri":"/2020/02/latex-pandoc-tutorial-basico/"},{"categories":null,"content":"Uso básico El comando más básico de Pandoc es, pandoc fileINPUT.txt -o fileOUTPUT.pdf Las extensiones que he puesto son de ejemplo, puedes ver algunas demos aquí. Tenemos varias opciones para pasarle a Pandoc, pero como vamos a usar LaTeX, dos que nos interesan son --latex-engine=COMPILADOR --template=RUTA La primera opción es la elección del compilador, ya sea pdflatex, xelatex, etc. Y la segunda opción es la ubicacion de la plantilla que vamos a usar. Esta es una de las cosas que más me gustan, eliges el estilo del documento al instante. Pandoc nos provee de una plantilla por defecto, que podemos extraer con pandoc -D latex \u003e plantilla.latex A partir de esta personalizamos nuestra plantilla y la podemos colocar (por ejemplo) en \\home\\user\\.config\\pandoc. ","date":"2020-02-17","objectID":"/2020/02/latex-pandoc-tutorial-basico/:0:2","tags":["latex","pandoc","tutorial"],"title":"[LaTeX/Pandoc] Tutorial Básico","uri":"/2020/02/latex-pandoc-tutorial-basico/"},{"categories":null,"content":"Plantillas Un buen punto de inicio es usar esta plantilla que es la del autor de Pandoc, y a partir de esta modificar a nuestro gusto. En la documentación de Pandoc podemos ver la sintaxis de las plantillas además de las variables que usa para LaTeX. Las plantillas al principio son un poco caos, sobre todo por la cantidad de opciones y parámetros a usar. Por eso mismo y para no hacer muy largo el artículo, lo dejaré para más adelante y así dedicarle una entrada específica. ","date":"2020-02-17","objectID":"/2020/02/latex-pandoc-tutorial-basico/:0:3","tags":["latex","pandoc","tutorial"],"title":"[LaTeX/Pandoc] Tutorial Básico","uri":"/2020/02/latex-pandoc-tutorial-basico/"},{"categories":null,"content":"Automatizar todo el proceso Al comando básico de Pandoc visto anteriormente se le pueden añadir más opciones como: -V: asignamos valores a las variables de la plantilla, e.g., -V documentclass=book. --toc: añadir un indice al documento. -N: numera las secciones. --filter FILTRO: añade funcionalidades adicionales incluidas en un filtro. Pasar todo esto en un solo comando se vuelve totalmente impracticable. Por ello vamos a usar YAML y MAKE. Metadatos YAML y Makefile En la plantilla nos aparacen un montón de variables, para poder asiganarle valores de una forma cómoda vamos a usar un archivo YAML. Un modelo puede ser el siguiente: --- # Datos title: Título author: Nombre lang: es # Control toc: True # Formato documentclass: article geometry: - top=1in - bottom=1in - right=0.5in - left=1.5in mainfont: LiberationSans fontsize: 12pt --- Este bloque YAML se puede añadir al inicio de nuestro Markdown o guardarlo en un archivo aparte e incluirlo en el comando de Pandoc: pandoc datos.yaml input.md -o output.pdf El comando se ha vuelto «manejable» pero aún así es largo por lo que vamos a crear un Makefile. Este archivo va a contener todas las órdenes y opciones para compilar nuestro Markdown. Primero creamos un archivo de nombre makefile (así tal cual, sin extensión ni nada), lo editamos y vamos a incluir el siguiente bloque de código: FILES = doc_markdown.md all: pandoc \\ --filter pandoc-crossref \\ --filter pandoc-citeproc \\ --template=/home/USER/.config/pandoc/plantilla.latex \\ -N \\ $(FILES) metadata.yaml \\ -f markdown -o OUTPUT.pdf clean: rm OUTPUT.pdf .PHONY: clean Explico un poco que tenemos: FILES: obviamente ahí indicamos el nombre del fichero Markdown. all: el comando Pandoc junto con todas las opciones. La barra invertida \\ es para partir el comando y que sea más legible. clean: para elminar el PDF. .PHONY: por si hay algún archivo que se llame clean. Ahora solo nos queda llamar a make: make Si queremos borrar el PDF: make clean Este archivo make es muy básico, se pueden hacer un montón de cosas a partir de aquí. Esta forma de automatizar el proceso es realmente simple y rápida, aunque dependiendo del editor que se use también es posible sin tener que usar un makefile. Workflow: ","date":"2020-02-17","objectID":"/2020/02/latex-pandoc-tutorial-basico/:0:4","tags":["latex","pandoc","tutorial"],"title":"[LaTeX/Pandoc] Tutorial Básico","uri":"/2020/02/latex-pandoc-tutorial-basico/"},{"categories":null,"content":"Referencias La opción Pandoc Math in MarkDown LaTeX and pandoc templates You got LaTeX in my Markdown! Converting Markdown to Beautiful PDF with Pandoc [Intro] Compilación, Linkado y Makefiles en C Generic Makefile for Markdown documentation ","date":"2020-02-17","objectID":"/2020/02/latex-pandoc-tutorial-basico/:0:5","tags":["latex","pandoc","tutorial"],"title":"[LaTeX/Pandoc] Tutorial Básico","uri":"/2020/02/latex-pandoc-tutorial-basico/"},{"categories":null,"content":"No existen sistemas infalibles y de vez en cuando las aplicaciones se quedan congeladas, no responden y por más que pinchemos el botón de cerrar no quiere cerrarse. En estos casos recurrimos a la terminal y podríamos usar xkill, pero puede pasar que notemos el sistema lento y no sepamos de donde viene. Para estas situaciones y conocer mejor lo que se está ejecutando, voy a mostrar de forma (intentaré que sea breve) ver los procesos que más usan la CPU y la memoria. ","date":"2020-02-10","objectID":"/2020/02/linux-matar-procesos/:0:0","tags":["linux","commands","tips"],"title":"[Linux] Matar Procesos","uri":"/2020/02/linux-matar-procesos/"},{"categories":null,"content":"Ver los procesos en ejecución Tenemos varias opciones: el administrador del sistema (depende la distribución que uses), top, ps, htop, … y un sin fin de utilidades gráficas y por CLI. Aquí trataré solo con ps y htop. ","date":"2020-02-10","objectID":"/2020/02/linux-matar-procesos/:1:0","tags":["linux","commands","tips"],"title":"[Linux] Matar Procesos","uri":"/2020/02/linux-matar-procesos/"},{"categories":null,"content":"PS Con ps se pueden hacer auténticas maravillas, pero vamos a lo que nos interesa. Vamos a listar los procesos de todos los usuarios (-a), la información del proceso (-u) y listar los procesos de todas las terminales y usuarios (-x): ps aux Esto nos saca un tochaco que a primera vista no gusta nada, vamos a refinarlo ps axc -o cmd:18,%cpu --sort=-%cpu | head Ahora mucho mejor, el comando anterior nos muestra de forma ordenada los procesos que están consumuendo mayor cantidad de CPU. Tip: usa un alias en tu .bashrc para ejecutarlo rapidamente. ","date":"2020-02-10","objectID":"/2020/02/linux-matar-procesos/:1:1","tags":["linux","commands","tips"],"title":"[Linux] Matar Procesos","uri":"/2020/02/linux-matar-procesos/"},{"categories":null,"content":"HTOP Otra forma de ver en vivo y en directo el consumo e información de los procesos, es con el comando htop, que por defecto no viene instalado en algunas distribuciones. Solo hemos de ejecutar: htop Con F3 buscamos la aplicación que nos interese, con F6 tenemos más opciones de ordenar los procesos, etc. ","date":"2020-02-10","objectID":"/2020/02/linux-matar-procesos/:1:2","tags":["linux","commands","tips"],"title":"[Linux] Matar Procesos","uri":"/2020/02/linux-matar-procesos/"},{"categories":null,"content":"Matar procesos ","date":"2020-02-10","objectID":"/2020/02/linux-matar-procesos/:2:0","tags":["linux","commands","tips"],"title":"[Linux] Matar Procesos","uri":"/2020/02/linux-matar-procesos/"},{"categories":null,"content":"Usando el PID del proceso Una forma de realizar esta acción es a través del PID del proceso, para conocer al susodicho tenemos varias opciones. Por ejemplo para conocer el PID de firefox: ps -ef | grep firefox pidof firefox El segundo es mucho más fácil puesto que nos saca directamente lo que buscamos. Ahora para matarlo usamos kill: kill -9 PID El parámetro -9 quiere decir que mata al proceso, puede parecer redundante pero tiene que ver con las señales del sistema. ","date":"2020-02-10","objectID":"/2020/02/linux-matar-procesos/:2:1","tags":["linux","commands","tips"],"title":"[Linux] Matar Procesos","uri":"/2020/02/linux-matar-procesos/"},{"categories":null,"content":"Usando el nombre del proceso El comando killall termina con todos los programas que conincidan con el nombre que le pasemos. Por ejemplo para matar firefox: killall -9 firefox Tenemos más opciones, una de ellas es poder terminar todos los procesos que está corriendo un usuario en particular: sudo killall -u usuario ","date":"2020-02-10","objectID":"/2020/02/linux-matar-procesos/:2:2","tags":["linux","commands","tips"],"title":"[Linux] Matar Procesos","uri":"/2020/02/linux-matar-procesos/"},{"categories":null,"content":"Usando parte del nombre del proceso Con pkill matamos los proceso especificando el nombre o parte del nombre. Al igual que en los ejemplos anteriores: pkill -9 firefox pkill puede enviar la señal al proceso de un usuario. Esto es, que queremos matar firefox para un usuario particular: pkill -9 -u usuario firefox ","date":"2020-02-10","objectID":"/2020/02/linux-matar-procesos/:2:3","tags":["linux","commands","tips"],"title":"[Linux] Matar Procesos","uri":"/2020/02/linux-matar-procesos/"},{"categories":null,"content":"Matar un proceso zombi Existen ocasiones que ejecutamos un programa y al cerrarlo dicho programa no se elimina de la tabla de procesos. No son dañinos pero ocupan espacio en la RAM. Es poco comun tener este tipo de procesos pero se puede dar el caso, de modo que vamos a buscarlos y eliminarlos. ps aux | grep Z Este comando nos lista los procesos zombi junto con su PID, por lo que ya solo queda hacer un kill -9 PID. ","date":"2020-02-10","objectID":"/2020/02/linux-matar-procesos/:3:0","tags":["linux","commands","tips"],"title":"[Linux] Matar Procesos","uri":"/2020/02/linux-matar-procesos/"},{"categories":null,"content":"Algunos comandos interesantes Expongo a continuación algunos comandos de ps con la salida formateada para ver solo el tanto por ciento de CPU o memoria: # Listamos los procesos que consumen mas CPU ps axc -o cmd:18,%cpu --sort=-%cpu | head # Saber el uso de CPU de un proceso ps axc -o cmd:18,%cpu | grep \u003cNombre proceso\u003e # Listar los procesos que consumen mas Memoria ps axc -o cmd:18,%mem --sort=-%mem | head # Saber el uso de Memoria de un proceso ps axc -o cmd:18,%mem | grep \u003cNombre proceso\u003e # Saber el uso de CPU y Memoria de un proceso mostrandolo de forma jerarquica ps axc -H --forest -o cmd:18,%cpu,%mem | grep containerd ","date":"2020-02-10","objectID":"/2020/02/linux-matar-procesos/:4:0","tags":["linux","commands","tips"],"title":"[Linux] Matar Procesos","uri":"/2020/02/linux-matar-procesos/"},{"categories":null,"content":" [LaTeX] Notas y Trucos [Vim] Notas y Trucos ","date":"2020-02-08","objectID":"/recursos/:0:0","tags":[""],"title":"Recursos","uri":"/recursos/"},{"categories":null,"content":"En esta página voy a ir almacenando pequeños trucos para la realización de documentos (no es la típica cheatsheet). Se trata más bien de las cosas usuales que nos surgen, como hacer anotaciones al margen, texto que envuelve una imagen, etc. ","date":"2020-01-26","objectID":"/pages/resources/latex-notas-trucos/:0:0","tags":["latex"],"title":"[LaTeX] Notas y Trucos","uri":"/pages/resources/latex-notas-trucos/"},{"categories":null,"content":"Webs Tables Generator Table Convert Detexify - LaTeX handwritten symbol recognition LaTeX Previewer ","date":"2020-01-26","objectID":"/pages/resources/latex-notas-trucos/:0:1","tags":["latex"],"title":"[LaTeX] Notas y Trucos","uri":"/pages/resources/latex-notas-trucos/"},{"categories":null,"content":"Listas ordenadas por letras Para tener listas ordenadas con letras minúsculas, usamos el paquete enumitem: \\begin{enumerate}[label=\\alph*] \\end{enumerate} Esto no daría una salida como la siguiente: a) Item b) Item c) Item ","date":"2020-01-26","objectID":"/pages/resources/latex-notas-trucos/:0:2","tags":["latex"],"title":"[LaTeX] Notas y Trucos","uri":"/pages/resources/latex-notas-trucos/"},{"categories":null,"content":"Anotaciones al margen Con el paquete marginnote tenemos más flexibilidad para usar notas al margen, como por ejemplo especificar la geometría de las notas. Documentación oficial ","date":"2020-01-26","objectID":"/pages/resources/latex-notas-trucos/:0:3","tags":["latex"],"title":"[LaTeX] Notas y Trucos","uri":"/pages/resources/latex-notas-trucos/"},{"categories":null,"content":"Eliminar borde de los enlaces Es conocido que al usar el paquete hyperref nos hace las referencias cruzadas, pero al generar el documento PDF algunos lectores dibujan unos bordes rojos alrededor de estas referencias (o de enlaces). Para evitar esto usamos una de las opciones del propio paquete: \\usepackage[hidelinks]{hyperref} o también \\hypersetup{hidelinks} Sin embargo, si lo que queremos es cambiar el color de los bordes o ponerlos más acordes a nuesro estilo: \\hypersetup{ colorlinks = true, % Colorea los enlaces urlcolor = blue, % Color para los hyperlinks linkcolor = blue, % Color para los enlaces internos citecolor = red % Color para las citas } ","date":"2020-01-26","objectID":"/pages/resources/latex-notas-trucos/:0:4","tags":["latex"],"title":"[LaTeX] Notas y Trucos","uri":"/pages/resources/latex-notas-trucos/"},{"categories":null,"content":"Suelo usar Vim con regularidad junto con Xfce como entorno de escritorio. Al hacer la típica operación de Abrir con… un archivo de texto, markdown o lo que sea, la quería hacer con (obviamente) Vim. Bien, estuve buscando información y lo que encontré es que debemos editar el fichero /usr/share/applications/vim.desktop y cambiar los siguientes valores: Exec=xfce4-terminal -e \"vim %F\" Terminal=false Pero esto me funcionó un tiempo (no estoy seguro de si fue después de alguna actualización) y tuve que volver a repetir lo anterior varias veces. No estoy dispuesto a hacer repetir esta tarea más veces, y la solución es crear un fichero .desktop (lo llamamos como nos de la gana) en ~/.local/share/applications/ con el siguiente contenido: [Desktop Entry] Encoding=UTF-8 Version=1.0 Type=Application NoDisplay=true Exec=\"xfce4-terminal -e 'vim %F'\" Name=\"VIMMMM\" Comment=Custom definition for \"xfce4-terminal -e 'vim %F'\" NOTA: otra opción sería copiar el archivo /usr/share/applications/vim.desktop y pegarlo en ~/.local/share/applications/ para posteriormente modificar las líneas Exec= y Terminal=. Ahora ya podemos abrir los ficheros en Vim desde Thunar pinchando dos veces sin tener que abrir la terminal ;) ","date":"2019-07-23","objectID":"/2019/07/abrir-con-vim-en-xfce/:0:0","tags":["linux","xfce","vim"],"title":"Abrir con VIM en Xfce","uri":"/2019/07/abrir-con-vim-en-xfce/"},{"categories":null,"content":"Una de las operaciones más habituales es importar ficheros. Pero cuando tratamos con alguno que es bien gordo, esta simple operación se vuelve una tortura, así que es mejor importar solo algunos datos. ","date":"2019-05-03","objectID":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/:0:0","tags":["python","pandas","data"],"title":"[Python/Pandas] Truquitos para ser más ágiles","uri":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/"},{"categories":null,"content":"read_csv Comando archiconocido, y uno de sus argumentos es nrows. Si añadimos, por ejemplo, nrows=5 como argumento de ese gran fichero, estaremos importando una pequeña porción. Si usamos GNU/Linux tenemos el comando head para ver las primeras líneas del documento, e.g.: head -n 5 data.csv Otra operación para cargar más rápido el documento, sería «sacar» las columnas que nos interesan, y si además sabemos el tipo de datos aún más rápida será la carga. Veamos un pequeño ejemplo: # Cargamos algunas filas del fichero df = pd.read_csv('data.csv', nrows=5) # Extraemos la lista de columnas df.columns.tolist() Esto nos devuelve la lista de columnas, por lo que ahora podemos cargas las columnas que nos interese, además de poder especifica el tipo de datos que es cada una para una carga más rápida: df = pd.read_csv('data.csv', usecols=['c1', 'c2'], dtype={'c1':str, 'c2':int}) Otra ventaja de este último argumento (dtype) es que si alguna columna contiene tanto cadenas como números, es la de declarar dicha columna como tipo string para no obtener errores cuando tratamos de unir tablas. ","date":"2019-05-03","objectID":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/:0:1","tags":["python","pandas","data"],"title":"[Python/Pandas] Truquitos para ser más ágiles","uri":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/"},{"categories":null,"content":"select_dtypes Una vez hecho el preprocesamiento de datos, podemos tenemos por defecto distintos tipos de datos en cada columna (bool, int64, float64, etc.), la distribución de los mismos la comprobamos con df.dtypes.value_counts() Con el anterior comando obtenemos todos los posibles tipos de datos del dataframe. Podemos hacer un sub-dataframe solo con los tipos de datos que desemos con el siguiente comando: df.select_dtypes(include=['float64', 'int64']) ","date":"2019-05-03","objectID":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/:0:2","tags":["python","pandas","data"],"title":"[Python/Pandas] Truquitos para ser más ágiles","uri":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/"},{"categories":null,"content":"copy Es obvia su función, pero podríamos pensar para que queremos este comando. Si por ejemplo hacemos una copia de un dataframe y se nos ocurre hacerlo así: import pandas as pd df1 = pd.DataFrame({ 'a':[0,0,0], 'b': [1,1,1]}) df2 = df1 df2['a'] = df2['a'] + 1 df1.head() El resultdo es que df1 ha cambiado dado que estamos apuntando al mismo sitio en memoria. Por esta razón necesitamos .copy(): df2 = df1.copy() Otra opción sería from copy import deepcopy df2 = deepcopy(df1) ","date":"2019-05-03","objectID":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/:0:3","tags":["python","pandas","data"],"title":"[Python/Pandas] Truquitos para ser más ágiles","uri":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/"},{"categories":null,"content":"map Se usa para hacer transformaciones de datos. Primero definimos un diccionario con las llaves sean los valores antiguos y los valores sean los nuevos valores. level_map = {1: 'high', 2: 'medium', 3: 'low'} df['c_level'] = df['c'].map(level_map) Algunos ejemplos: True, False a 1, 0; definir niveles; etc. ","date":"2019-05-03","objectID":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/:0:4","tags":["python","pandas","data"],"title":"[Python/Pandas] Truquitos para ser más ágiles","uri":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/"},{"categories":null,"content":"value counts Es un comando para verificar las distribuciones de valores. Por ejemplo, si queremos comprobar los posibles valores y la frecuencia para cada valor individual en la columna 'c' podemos hacer df['c'].value_counts() Algunos trucos/argumentos útiles: normalize = True: si queremos comprobar la frecuencia en lugar de hacer el recuento. dropna = False: si queremos incluir los valores perdidos (missing values) en las estadísticas. df['c'].value_counts().reset_index(): si queremos convertir la tabla de estadísticas a un dataframe. df['c'].value_counts().sort_index(): para mostrar las estadísticas ordenadas según los valores de la columna ['c']. ","date":"2019-05-03","objectID":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/:0:5","tags":["python","pandas","data"],"title":"[Python/Pandas] Truquitos para ser más ágiles","uri":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/"},{"categories":null,"content":"Número de valores perdidos (missing values) Al importar algunos datasets o por estar haciendo algún modelo, nos encontrar con los missing values en filas o columnas. Usamos .isnull() y .sum() para contar el número de valores perdidos que hay en las columnas que especifiquemos. import pandas as pd import numpy as np df = pd.DataFrame({ 'id': [1,2,3], 'c1':[0,0,np.nan], 'c2': [np.nan,1,1]}) df = df[['id', 'c1', 'c2']] df['num_nulls'] = df[['c1', 'c2']].isnull().sum(axis=1) df.head() ","date":"2019-05-03","objectID":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/:0:6","tags":["python","pandas","data"],"title":"[Python/Pandas] Truquitos para ser más ágiles","uri":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/"},{"categories":null,"content":"Seleccionar filas especificando los IDs En SQL al hacer SELECT * FROM ... WHERE ID in ('A001', 'C022', ...) obtenemos los registros de los IDs especificados. Para hacer lo mismo en Pandas: df_filter = df['ID'].isin(['A001','C022',...]) df[df_filter] ","date":"2019-05-03","objectID":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/:0:7","tags":["python","pandas","data"],"title":"[Python/Pandas] Truquitos para ser más ágiles","uri":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/"},{"categories":null,"content":"Grupos de percentiles Tenemos una columna numérica y queremos clasificar los valores en dicha columna en grupos, digamos que el 5% superior en el grupo 1, 5-20% en el grupo 2, 20-50% en el grupo 3 y el 50% inferior en el grupo 4. import numpy as np cut_points = [np.percentile(df['c'], i) for i in [50, 80, 95]] df['group'] = 1 for i in range(3): df['group'] = df['group'] + (df['c'] \u003c cut_points[i]) # or \u003c= cut_points[i] Otra opción sería con pandas.cut(). ","date":"2019-05-03","objectID":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/:0:8","tags":["python","pandas","data"],"title":"[Python/Pandas] Truquitos para ser más ágiles","uri":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/"},{"categories":null,"content":"to_csv Comando utilizado por todos/as, pero veamos un par de trucos adicionales. El primero es, print(df[:5].to_csv()) Imprime las primeras cinco filas pero de la forma exacta en que se guardan. El segundo truco es al tratar con números enteros y valores perdidos mezclados. Si una columna tienen tanto valores enteros como perdidos, el tipo de dato sería flotante en lugar de entero. Cuando exportamos la tabla podemos añadir el argumento float_format='%.0f' para redondear todos los flotantes a enteros. ","date":"2019-05-03","objectID":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/:0:9","tags":["python","pandas","data"],"title":"[Python/Pandas] Truquitos para ser más ágiles","uri":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/"},{"categories":null,"content":"Muestras aleatorias En algunos casos queremos ver una muestra aleatoria de más de una fila. Si por ejemplo queremos una muestra de tamaño 200 hacemos df.sample(n=200).head(10) Otra forma de hacerlo es con NumPy: import numpy as np rows = np.random.choice(df.index.values, 200) df200 = df.loc[rows] df200.head() Referencias: 10 Python Pandas tricks that make your work more efficient How to use Pandas sample to select rows and columns Python Data Science Handbook, Jake VanderPlas ","date":"2019-05-03","objectID":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/:0:10","tags":["python","pandas","data"],"title":"[Python/Pandas] Truquitos para ser más ágiles","uri":"/2019/05/python-pandas-truquitos-para-ser-mas-agiles/"},{"categories":null,"content":" El deporte y los datos, que gran combinación ;-) La copa del rey de baloncesto es una competición al más puro estilo de la final four de la Euroliga, por ello y como ya hice anteriormente, vamos a analizar los partidos mediante una gráfica tipo PES, FIFA, etc. Para ello tomamos las siguientes variables: 3PA 3-Point Attempted 3-Puntos Intentados 3PM 3-Point Made 3-Puntos Anotados FGA Field Goals Attempted Tiros de Campo Intentados FGM Field Goals Made Tiros de Campo Anotados PTS Points Puntos BLK Blocks Tapones TO Turnovers Pérdidas STL Steals Robos AST Assists Asistencias Def. REB Defensive Rebounds Rebotes Defensivos Off. REB Offensive Rebounds Rebotes Ofensivos Estas variables son muy usuales y representativas a la hora de comparar dos equipos de un vistazo y sin entrar en demasiados detalles. Voy a analizar cada partido, y los datos a representar son la media de la liga regular 2018 /2019 junto con las estadísticas del partido en cuestión. Esto lo hago así para ver lo que se esparaba que hiciera el equipo y lo ha pasado en el partido. No voy a normalizar los datos, si no que tomaré a los dos equipos que se enfrentan en las distintas eliminatorias y sobre la máxima entre la media de liga y los datos del partido hago el baremo. Todos los datos son los ofrecidos por la ACB. ","date":"2019-02-15","objectID":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/:0:0","tags":["data science","data","deporte"],"title":"Estadística y la Copa del Rey ACB 18-19","uri":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/"},{"categories":null,"content":"Cuartos de Final: Iberostar Tenerife - Unicaja Primer partido disputado y primera sorpresa. Tras la buena racha que traía Unicaja, se espera otro resultado, veamos la gráfica: (Nota: si se pincha en el color del equipo en la leyenda se oculta dicho equipo) Lo que se esperaba: Unicaja a priori estaba un poquito por encima, anota más (mayores tiros de campo convertidos y puntos por partido) y coge más rebotes ofensivos que siempre es un plus. En cambio Iberostar Tenerife defiende mejor y mantiene el mismo porcentaje de 3 y 2 puntos que Unicaja. Lo que pasó: La solidez y acierto desde el línea de tres del Iberostar Tenerife se impuso al equipo malagueño. Si además de esos factores sumamos como se ve en la gráfica el buen hacer en el rebote tanto defensivo como ofensivo y los tiros de campo convertidos del Tenerife, el Unicaja estuvo casi a merced de los tinerfeños. ","date":"2019-02-15","objectID":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/:0:1","tags":["data science","data","deporte"],"title":"Estadística y la Copa del Rey ACB 18-19","uri":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/"},{"categories":null,"content":"Cuartos de Final: Barça Lassa - Valencia Basket Segundo partido y los 3 últimos minutos agotaron al Valencia. El Barça llega líder de la liga y su experiencia en este tipo de partidos se impuso a un Valencia que aguantó hasta los minutos finales. Lo que se esperaba: Un Barça que impusiera su ritmo de principio a fin. Mejores en rebote (defensivo y ofensivo), en porcentaje de tiro de tres, puntos anotados, tiros de campo y defensa. Lo que pasó: El Valencia salió con más ganas y con un puntito de más en defensa, pero se impuso el acierto en tiros de campo de los catalanes y su experiencia. Cabe destacar las pérdidas en momentos muy importantes del partido por parte del Valencia. ","date":"2019-02-15","objectID":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/:0:2","tags":["data science","data","deporte"],"title":"Estadística y la Copa del Rey ACB 18-19","uri":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/"},{"categories":null,"content":"Cuartos de Final: K. Baskonia - D. S. Joventut Tercer partido de copa al ritmo de Nico Laprovittola. Todo el partido estuvo a su merced y se jugaba a lo que él queria. El equipo vitoriano salió a medio gas y terminó a remolque del base argentino del Joventut. Lo que se esperaba: Un partido competido que se que se decidiera en el último cuarto. Aún con las ausencias de Shengelia y Granger, los baskonistas podían haber ganado, prueba de ello es la defensa que llevan haciendo durante toda la liga junto con la anotación. Lo que pasó: Laprovittola. Salió con ganas de ganar y hacer historia en la copa y lo consiguió. La penya quiso ganar desde el principio y estuvo por encima en todos los aspectos. Laprovittola junto con Todorovic sentenciaron al Baskonia que desde el primer cuarto salió perdido y sin saber que hacer para ganar. ","date":"2019-02-15","objectID":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/:0:3","tags":["data science","data","deporte"],"title":"Estadística y la Copa del Rey ACB 18-19","uri":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/"},{"categories":null,"content":"Cuartos de Final: Real Madrid - M. Estudiantes Cuarto partido y último partido de los cuartos de final. Ilusión estudiantil por ganar de nuevo a su eterno rival (como ya hicieron en liga), pero Campazzo, Ayón y compañia pusieron tierra de por medio antes de lo previsto. Lo que se esperaba: Un partido algo más igualado de lo esperado y que el Estudiantes sacara más garra. Por otra parte el Madrid sigue en su línea de juego y control del partido. Lo que pasó: Un Madrid arrollador que no dió ninguna opción al Estudiantes. ","date":"2019-02-15","objectID":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/:0:4","tags":["data science","data","deporte"],"title":"Estadística y la Copa del Rey ACB 18-19","uri":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/"},{"categories":null,"content":"Semifinal: Barça Lassa - I. Tenerife Primer partido de las semifinales y primera gran polémica de la copa. A priori los catalanes llegan con ventaja en aspectos muy vitales del juego: rebote, anotación y porcentaje en tiros de tres. El partido como se preveia lo dominó el Barça con una gran defensa, aprovechando las malas decisiones de tiro por parte del Tenerife junto con una defensa blanda. Pero llegó el último cuarto y con él un arreón de los tinerfeños que los puso a dos posesiones de empatar el partido. Prueba de ello es el rebote ofensivo y el porcentaje de triple. Una técnica muy discutido a falta de un minuto marcó la diferencia y la polémica. ","date":"2019-02-15","objectID":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/:0:5","tags":["data science","data","deporte"],"title":"Estadística y la Copa del Rey ACB 18-19","uri":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/"},{"categories":null,"content":"Semifinal: Real Madrid - D. S. Joventut Segunda semifinal con sabor amargo para el Joventut después del gran partido de cuartos. Se esperaba una mejor defensa de los catalanes, pero la buena defensa vino por parte del Madrid. Como se puede apreciar en la gráfica, el partido estuvo marcado por el rebote madrileño y un buen porcentaje de anotación. En cambio, el Joventut no cerró el poste bajo, perdió demasiados balones y a Nico Laprovittola se le estuvo esperando todo el partido; totalmente desconocido respecto a su anterior aparición. ","date":"2019-02-15","objectID":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/:0:6","tags":["data science","data","deporte"],"title":"Estadística y la Copa del Rey ACB 18-19","uri":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/"},{"categories":null,"content":"Final: Real Madrid - Barça Lassa Final con un clásico y mucha polémica. El primer y segundo cuarto muy igualados, llegando empatados al descanso. El tercer cuarto pintaba merengue y el Barça despertó en el último cuarto con un Llull haciendo de las suyas. Las decisiones arbitrales tuvieron un peso demasiado importante en el partido. Hasta la fecha los dos mejores equipos de la liga se encontraban en otra final. Ambos iguales, pero el factor cancha y la defensa del Madrid preveían la victoria a su favor. Lo que nos escontramos en el partido, es un rebote tanto defensivo como ofensivo dominado por el Madrid, mejor acierto en tiro para el Barça y algo que no aprecia en las gráficas, el mal sabor de boca que deja la actuación arbitral. Actualizado el 17/02/2019 ","date":"2019-02-15","objectID":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/:0:7","tags":["data science","data","deporte"],"title":"Estadística y la Copa del Rey ACB 18-19","uri":"/2019/02/estadistica-y-la-copa-del-rey-acb-18-19/"},{"categories":null,"content":"Poco a poco voy conociendo más cosas sobre Vim, y lo que antes me parecía un tarea ardua ahora lo hago con más rapidez. Cierto es que al principio cuesta y una cosa que echaba de menos era tener un corrector ortográfico (por lo que pudiera pasar). Voy a mostrar varias cositas y trucos para tener lo necesario ante este tema. Para activarlo lo hacemos con el comando: :setlocal spell Esto puede (probablemente) no escoja por defecto nuestro idioma, pero tranquilos no pasa nada, lo especificamos tal que :setlocal spell spelllang=es Bien ahora si marcha la cosa, nos resalta las palabras que tengan algún error. ¿Cómo navego por los errores? Fácil, con ]s vamos hacia adelante y con [s hacia atrás. Una vez estemos encima de la palabra con z= nos da un listado de sugerencias, y con zg añadimos la palabra al diccionario o zw para eliminarla. Como ya he terminado de corregir las faltas de ortografía quiero desactivarla, :set nospell Si por defecto al abrir Vim queremos tener la corrección ortográfica, editamos nuestro .vimrc e incluimos lo siguiente set spelllang=es Otra cosa que se me ocurre es si trabajamos en diferentes idiomas, lo suyo sería poder activar la corrección dependiendo del idioma en que estemos escribiendo, entonces nos creamos un atajo en .vimrc: nnoremap \u003csilent\u003e \u003cC-g\u003e :set spell spelllang=es\u003cCR\u003e nnoremap \u003csilent\u003e \u003cC-f\u003e :set spell spelllang=en\u003cCR\u003e Entonces en el modo normal pulsamos Ctrl+g para activar el diccionario español o Ctrl+f para activar el diccionario inglés. ","date":"2019-02-01","objectID":"/2019/02/vim-correccion-ortografica/:0:0","tags":["vim"],"title":"[Vim] Corrección Ortográfica","uri":"/2019/02/vim-correccion-ortografica/"},{"categories":null,"content":" Ahora que ya tenemos al caer la Final Four de Belgrado, vamos echar un vistazo atrás y ver como ha sido la temporada para los equipos implicados. Empezamos por la temporada regular, es decir, sin contar los Playoff. He tomado las siguientes variables: 3PA3-Point Attempted3-Puntos Intentados3PM3-Point Made3-Puntos AnotadosFGAField Goals AttemptedTiros de Campo IntentadosFGMField Goals MadeTiros de Campo AnotadosPTSPointsPuntosBLKBlocksTaponesTOTurnoversPérdidasSTLStealsRobosASTAssistsAsistenciasDef. REBDefensive ReboundsRebotes DefensivosOff. REBOffensive ReboundsRebotes Ofensivos He elegido estas porque creo que son bastante representativas a la hora de comparar dos equipos. Tras recoger los datos ofrecidos por la web de la Euroliga, hago una gráfica tipo FIFA, PES, etc. Es lo que se suele llamar una Radar Chart. Antes de sacar conclusiones voy a explicar que está representado. En ambas gráficas he tomado la media de la temporada regular 2017/2018. Para la primera se han calculado los valores tomando el 100% como el máximo, y sobre este cuanto corresponde los siguientes valores. En la segunda se normalizan los datos, por lo que el máximo es 1 y el mínimo es 0. De esta forma se aprecian mejor las diferencias, pero no queda tan llamativo como la primera gráfica. (Nota: si se pincha en el color del equipo en la leyenda se oculta dicho equipo) Ahora ya si podemos empezar ha valorar la temporada regular, pero lo haré según los enfrentamiento de semifinales. CSKA-Real Madrid. Obviamente el CSKA es el equipo con mayor anotación, tiros de campo anotados y robos por partido. El Real Madrid tiene mayor cantidad de triples anotados pero también intentados, cosa que si lo vemos en el CSKA tienen menos triples anotados pero son más efectivos. Otro aspecto fundamental a favor del Real Madrid son los rebotes defensivos. Fenerbahce-Zalgiris. Al ver las gráficas tenderíamos a decir que el Fenerbahce lo tiene “fácil”. Pero si hacemos una lectura tranquilamente veremos que los tiros de campo ambos equipos están igualados, y al porcentaje de triples le pasa lo mismo, pero con una salvedad, el Fenerbahce anota algunos más. Con el tipo de baloncesto actual esto puede suponer la victoria. ","date":"2018-05-13","objectID":"/2018/05/estadisticas-y-la-final-four-de-belgrado/:0:0","tags":["data","data science","deporte"],"title":"Estadística y la Final Four de Belgrado","uri":"/2018/05/estadisticas-y-la-final-four-de-belgrado/"},{"categories":null,"content":"Playoff Durante los Playoff los equipos pueden haber perdido/recuperado jugadores importantes, cambiado los esquemas por las eliminatorias u otros factores, por lo que resulta interesante observar si ha habido grandes cambios. CSKA-Real Madrid. CSKA mejora en puntos, rebotes ofensivos y tiros de campo, vamos que mejora su parte ofensiva aún dejando un poco atrás el triple. El Real Madrid baja en casi todos los aspectos excepto en el rebote defensivo. Fenerbahce-Zalgiris. Fenerbahce ha seguido en su línea pero mejorando en los tiros y anotación, por contra de no coger tantos rebotes como durante la temporada regular. Zalgiris se ha hecho fuerte en defensa, cogienddo más rebotes, perdiendo menos balones además de anotar más aún no siendo el triple su principal baza. ","date":"2018-05-13","objectID":"/2018/05/estadisticas-y-la-final-four-de-belgrado/:1:0","tags":["data","data science","deporte"],"title":"Estadística y la Final Four de Belgrado","uri":"/2018/05/estadisticas-y-la-final-four-de-belgrado/"},{"categories":null,"content":"Jugadores Para terminar voy a hacer un gráfico de burbujas (o bubble plot) con algunas de las categorías más relevantes en la estadística. Lo haré para la temporada regular y tomando la media por partido. ","date":"2018-05-13","objectID":"/2018/05/estadisticas-y-la-final-four-de-belgrado/:2:0","tags":["data","data science","deporte"],"title":"Estadística y la Final Four de Belgrado","uri":"/2018/05/estadisticas-y-la-final-four-de-belgrado/"},{"categories":null,"content":"Media en tiros de 2 (en %) ","date":"2018-05-13","objectID":"/2018/05/estadisticas-y-la-final-four-de-belgrado/:2:1","tags":["data","data science","deporte"],"title":"Estadística y la Final Four de Belgrado","uri":"/2018/05/estadisticas-y-la-final-four-de-belgrado/"},{"categories":null,"content":"Media en tiros de 3 (en %) ","date":"2018-05-13","objectID":"/2018/05/estadisticas-y-la-final-four-de-belgrado/:2:2","tags":["data","data science","deporte"],"title":"Estadística y la Final Four de Belgrado","uri":"/2018/05/estadisticas-y-la-final-four-de-belgrado/"},{"categories":null,"content":"Media de puntos por partido ","date":"2018-05-13","objectID":"/2018/05/estadisticas-y-la-final-four-de-belgrado/:2:3","tags":["data","data science","deporte"],"title":"Estadística y la Final Four de Belgrado","uri":"/2018/05/estadisticas-y-la-final-four-de-belgrado/"},{"categories":null,"content":"Media de rebotes por partido ","date":"2018-05-13","objectID":"/2018/05/estadisticas-y-la-final-four-de-belgrado/:2:4","tags":["data","data science","deporte"],"title":"Estadística y la Final Four de Belgrado","uri":"/2018/05/estadisticas-y-la-final-four-de-belgrado/"},{"categories":null,"content":"Media de asistencias por partido ","date":"2018-05-13","objectID":"/2018/05/estadisticas-y-la-final-four-de-belgrado/:2:5","tags":["data","data science","deporte"],"title":"Estadística y la Final Four de Belgrado","uri":"/2018/05/estadisticas-y-la-final-four-de-belgrado/"},{"categories":null,"content":"Media de robos por partido ","date":"2018-05-13","objectID":"/2018/05/estadisticas-y-la-final-four-de-belgrado/:2:6","tags":["data","data science","deporte"],"title":"Estadística y la Final Four de Belgrado","uri":"/2018/05/estadisticas-y-la-final-four-de-belgrado/"},{"categories":null,"content":"Para empezar a comprender el mundo (La)TeX hay que tener unas nociones básicas de que es en sí y sus distintas variantes. ","date":"2018-04-01","objectID":"/2018/04/latex-capitulo-1-compiladores/:0:0","tags":["latex"],"title":"[LaTeX] Capítulo 1: Compiladores","uri":"/2018/04/latex-capitulo-1-compiladores/"},{"categories":null,"content":"TeX TeX es un nuevo sistema de composición tipográfica dirigido a la creación de libros bonitos, y especialmente para libros que contienen un montón de matemáticas. Al preparar un manuscrito en formato TeX, estarás diciendo a la computadora exactamente como el manuscrito debe ser transformado en páginas cuyas calidad tipográfica es comparable a la de los mejores impresores del mundo Esto es como definió Donald Knuth (su creador) que era TeX en el libro The TeXbook. Es la base de todo el sistema y lo primero que se creó allá por 1978. TeX es un lenguaje basado en macros y tokens. Tiene un conocimiento preciso de los tamaños de todos los caracteres y símbolos, y usando esta información calcula la disposición óptima de letras por línea y líneas por página. Cuando compilamos (por ejemplo por una CLI con tex example.tex) el resultado es un fichero DVI que contiene la localización final de todos los caracteres. Este fichero se puede convertir a otros formatos o directamente imprimir. El sistema base contiene unos 300 comandos llamados primitivos. Son comandos de bajo nivel, pero la mayor parte de la funcionalidad es proporcionada por archivos de formato. El formato por defecto original de Knuth, que añade unos 600 comandos, es Plain TeX. ","date":"2018-04-01","objectID":"/2018/04/latex-capitulo-1-compiladores/:1:0","tags":["latex"],"title":"[LaTeX] Capítulo 1: Compiladores","uri":"/2018/04/latex-capitulo-1-compiladores/"},{"categories":null,"content":"LaTeX Con TeX se podían hacer cosas básicas, por lo que pronto surge la necesidad de realizar cosas más complejas y completas. Entra en escena Leslie Lamport, que crea LaTeX a principios de la década de 1980. LaTeX es un conjunto de comandos definidos en términos de los subyacentes a TeX. De hecho todos los comandos usados en un documento LaTeX son en realidad conjuntos de comandos de TeX. Lo que hace es proporcionarnos un lenguaje de alto nivel que acceda al poder de TeX de una manera más fácil. Podríamos establecer la siguiente diferencia entre ellos: TeX se ocupa de la maquetación, mientras que LaTeX maneja el lado del contenido para el procesamiento de documentos. Gracias a que Leslie Lamport creó un sistema estandarizado de gestión de paquetes, la comunidad creció enormemente. Precisamente por esto tenemos paquetes para cualquier cosa y clases de documentos para todo lo que necesitemos. OJO: para mantener tu reputación en el mundo LaTeX tienes que escribirlo con una T y X mayuscula, y pronunciarlo como Lay-Tech. Esto se debe a que la X en TeX es en realidad la letra Chi mayúscula del griego. (Post en construcción) ","date":"2018-04-01","objectID":"/2018/04/latex-capitulo-1-compiladores/:2:0","tags":["latex"],"title":"[LaTeX] Capítulo 1: Compiladores","uri":"/2018/04/latex-capitulo-1-compiladores/"},{"categories":null,"content":"Referencias https://www.latex-project.org/ https://www.sharelatex.com/blog/2012/12/01/the-tex-family-tree-latex-pdftex-xelatex-luatex-context.html https://en.wikipedia.org/wiki/TeX https://en.wikipedia.org/wiki/LaTeX The LaTeX Companion, Frank Mittelbach. The TeXbook, Donald E. Knuth. ","date":"2018-04-01","objectID":"/2018/04/latex-capitulo-1-compiladores/:3:0","tags":["latex"],"title":"[LaTeX] Capítulo 1: Compiladores","uri":"/2018/04/latex-capitulo-1-compiladores/"},{"categories":null,"content":"Under construction ¯\\(ツ)/¯ ","date":"2018-03-31","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Hello Everyone! ","date":"2018-03-31","objectID":"/2018/03/hello-world/:0:0","tags":null,"title":"Hello World","uri":"/2018/03/hello-world/"}]